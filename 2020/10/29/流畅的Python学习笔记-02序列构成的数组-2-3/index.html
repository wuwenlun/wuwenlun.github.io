<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="第二章第三节：元组不仅仅是不可变的列表">
<meta property="og:type" content="article">
<meta property="og:title" content="流畅的Python学习笔记-02序列构成的数组-2-3">
<meta property="og:url" content="http://example.com/2020/10/29/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84-2-3/index.html">
<meta property="og:site_name" content="科学尽头是神学">
<meta property="og:description" content="第二章第三节：元组不仅仅是不可变的列表">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028144038.png">
<meta property="article:published_time" content="2020-10-29T08:43:50.000Z">
<meta property="article:modified_time" content="2020-11-03T09:51:54.842Z">
<meta property="article:author" content="wu">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028144038.png">

<link rel="canonical" href="http://example.com/2020/10/29/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84-2-3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>流畅的Python学习笔记-02序列构成的数组-2-3 | 科学尽头是神学</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">科学尽头是神学</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">于桃子，我爱你</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/10/29/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84-2-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/wu_avatar.png">
      <meta itemprop="name" content="wu">
      <meta itemprop="description" content="宇宙的尽头到底是什么">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="科学尽头是神学">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          流畅的Python学习笔记-02序列构成的数组-2-3
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-29 16:43:50" itemprop="dateCreated datePublished" datetime="2020-10-29T16:43:50+08:00">2020-10-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-03 17:51:54" itemprop="dateModified" datetime="2020-11-03T17:51:54+08:00">2020-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%81%E7%95%85%E7%9A%84Python/" itemprop="url" rel="index"><span itemprop="name">流畅的Python</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B5%81%E7%95%85%E7%9A%84Python/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84/" itemprop="url" rel="index"><span itemprop="name">第二章 序列构成的数组</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>第二章第三节：元组不仅仅是不可变的列表</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028144038.png"></p>
<a id="more"></a>

<p>有些 Python 入门教程把元组称为“不可变列表”，然而这并没有完全概括元组的特点。除了用作不可变的列表，它还可以用于没有字段名的记录。鉴于后者常常被忽略，我们先来看看元组作为记录的功能。</p>
<h3 id="元组和记录"><a href="#元组和记录" class="headerlink" title="元组和记录"></a>元组和记录</h3><p>元组其实是对数据的记录：元组中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置。正是这个位置信息给数据赋予了意义。</p>
<p>如果只把元组理解为不可变的列表，那其他信息——它所含有的元素的总数和它们的位置——似乎就变得可有可无。但是如果把元组当作一些字段的集合，那么数量和位置信息就变得非常重要了。</p>
<p>示例 2-7 中的元组就被当作记录。如果在任何的表达式里我们在元组内对元素排序，这些元素所携带的信息就会丢失，因为这些信息是跟它们的位置有关的。</p>
<p>示例 2-7 把元组用作记录：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lax_coordinates = (<span class="number">33.9425</span>, <span class="number">-118.408056</span>) ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>city, year, pop, chg, area = (<span class="string">&#x27;Tokyo&#x27;</span>, <span class="number">2003</span>, <span class="number">32450</span>, <span class="number">0.66</span>, <span class="number">8014</span>) ➋</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>traveler_ids = [(<span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;31195855&#x27;</span>), (<span class="string">&#x27;BRA&#x27;</span>, <span class="string">&#x27;CE342567&#x27;</span>), ➌</span><br><span class="line"><span class="meta">... </span>(<span class="string">&#x27;ESP&#x27;</span>, <span class="string">&#x27;XDA205856&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> passport <span class="keyword">in</span> sorted(traveler_ids): ➍</span><br><span class="line"><span class="meta">... </span>print(<span class="string">&#x27;%s/%s&#x27;</span> % passport) ➎</span><br><span class="line">...</span><br><span class="line">BRA/CE342567</span><br><span class="line">ESP/XDA205856</span><br><span class="line">USA/<span class="number">31195855</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> country, _ <span class="keyword">in</span> traveler_ids: ➏</span><br><span class="line"><span class="meta">... </span>print(country)</span><br><span class="line">...</span><br><span class="line">USA</span><br><span class="line">BRA</span><br><span class="line">ESP</span><br></pre></td></tr></table></figure>

<p>❶ 洛杉矶国际机场的经纬度。</p>
<p>❷ 东京市的一些信息：市名、年份、人口（单位：百万）、人口变化（单位：百分比）和面积（单位：平方千米）。</p>
<p>❸ 一个元组列表，元组的形式为 (country_code, passport_number)。</p>
<p>❹ 在迭代的过程中，passport 变量被绑定到每个元组上。</p>
<p>❺ % 格式运算符能被匹配到对应的元组元素上。</p>
<p>❻ for 循环可以分别提取元组里的元素，也叫作拆包（unpacking）。因为元组中第二个元素对我们没有什么用，所以它赋值给“_”占位符。</p>
<p>拆包让元组可以完美地被当作记录来使用，这也是下一节的话题。</p>
<h3 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h3><p>示例 2-7 中，我们把元组 (‘Tokyo’, 2003, 32450, 0.66, 8014) 里的元素分别赋值给变量 city、year、pop、chg 和 area，而这所有的赋值我们只用一行声明就写完了。同样，在后面一行中，一个 % 运算符就把 passport 元组里的元素对应到了 print 函数的格式字符串空档中。这两个都是对元组拆包的应用。</p>
<p><strong>元组拆包可以应用到任何可迭代对象上</strong>，唯一的硬性要求是，被可迭代对象中的元素数量必须要跟接受这些元素的元组的空档数一致。除非我们用 <code>*</code> 来表示忽略多余的元素，在用 <code>*</code> 来处理多余的元素一节里，我会讲到它的具体用法。Python 爱好者们很喜欢用元组拆包这个说法，但是可迭代元素拆包这个表达也慢慢流行了起来，比如“PEP 3132—Extended IterableUnpacking”（<a target="_blank" rel="noopener" href="https://www.python.org/dev/peps/pep-3132/">https://www.python.org/dev/peps/pep-3132/</a>）的标题就是这么用的。</p>
<p>上面提到<font color=red><strong>元组拆包可以应用到任何可迭代对象上</strong></font>，这句话要怎么理解呢？看下面一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFib</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pre = <span class="number">0</span></span><br><span class="line">        self.curr = <span class="number">1</span></span><br><span class="line">        self.lists = [ii <span class="keyword">for</span> ii <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.lists[item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fib = MyFib()</span><br><span class="line">    fic = iter(fib)<span class="comment"># 因为类有__getitem__方法，即使它没有__iter__方法，也可以经过iter内置函数获得MyFib的迭代器对象</span></span><br><span class="line">    a, *b, c = fic<span class="comment"># 科迭代对象经过拆包，把其内部属性lists分别拆包赋值给a、b、c变量</span></span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    print(c)</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;<span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">&gt;&gt;&gt;<span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 Python 开发中经常可以看到变量交换的代码，非常优雅，不使用中间变量交换两个变量的值，如下的方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b, a = a, b</span><br></pre></td></tr></table></figure>

<p>其实 <code>=</code> 号右边就是一个元组，然后拆包赋值给 b 和 a 两个变量。怎么看 <code>=</code> 号右边是一个元组呢？通过下面代码来论证：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="number">10</span></span><br><span class="line">    c = a, b</span><br><span class="line">    print(c)</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;(<span class="number">5</span>, <span class="number">10</span>)<span class="comment"># 变量c打印出来就是一个元组    </span></span><br></pre></td></tr></table></figure>

<p>可以用 <code>*</code> 运算符把一个可迭代对象拆开作为函数的参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>divmod(<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divmod(*t)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quotient, remainder = divmod(*t)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quotient, remainder</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>下面是另一个例子，这里元组拆包的用法则是让一个函数可以用元组的形式返回多个值，然后调用函数的代码就能轻松地接受这些返回值。比如 os.path.split() 函数就会返回以路径和最后一个文件名组成的元组 (path, last_part):</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path, filename = os.path.split(<span class="string">&#x27;/home/luciano/.ssh/idrsa.pub&#x27;</span>)</span><br><span class="line">    print(path)</span><br><span class="line">    print(filename)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;/home/luciano/.ssh</span><br><span class="line">&gt;&gt;&gt;idrsa.pub</span><br></pre></td></tr></table></figure>

<p>在进行拆包的时候，我们不总是对元组里所有的数据都感兴趣，<code>_</code> 占位符能帮助处理这种情况，上面这段代码也展示了它的用法。</p>
<p>除此之外，在元组拆包中使用 <code>*</code> 也可以帮助我们把注意力集中在元组的部分元素上。</p>
<p>用 <code>*</code> 来处理剩下的元素。</p>
<p>在 Python 中，函数用 <code>*args</code> 来获取不确定数量的参数算是一种经典写法了。</p>
<p>于是 Python 3 里，这个概念被扩展到了平行赋值中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = range(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = range(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = range(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [])</span><br></pre></td></tr></table></figure>

<p>在平行赋值中，<code>*</code> 前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式的任意位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *body, c, d = range(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, body, c, d</span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*head, b, c, d = range(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>head, b, c, d</span><br><span class="line">([<span class="number">0</span>, <span class="number">1</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>另外元组拆包还有个强大的功能，那就是可以应用在嵌套结构中。</p>
<h3 id="嵌套元组拆包"><a href="#嵌套元组拆包" class="headerlink" title="嵌套元组拆包"></a>嵌套元组拆包</h3><p>接受表达式的元组可以是嵌套式的，例如 (a, b, (c, d))。只要这个接受元组的嵌套结构符合表达式本身的嵌套结构，Python 就可以作出正确的对应。示例 2-8 就是对嵌套元组拆包的应用。</p>
<p>示例 2-8 用嵌套元组来获取经度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">(<span class="string">&#x27;Tokyo&#x27;</span>,<span class="string">&#x27;JP&#x27;</span>,<span class="number">36.933</span>,(<span class="number">35.689722</span>,<span class="number">139.691667</span>)), <span class="comment"># ➊</span></span><br><span class="line">(<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">(<span class="string">&#x27;Mexico City&#x27;</span>, <span class="string">&#x27;MX&#x27;</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, <span class="number">-99.133333</span>)),</span><br><span class="line">(<span class="string">&#x27;New York-Newark&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, <span class="number">-74.020386</span>)),</span><br><span class="line">(<span class="string">&#x27;Sao Paulo&#x27;</span>, <span class="string">&#x27;BR&#x27;</span>, <span class="number">19.649</span>, (<span class="number">-23.547778</span>, <span class="number">-46.635833</span>)),</span><br><span class="line">]</span><br><span class="line">print(<span class="string">&#x27;&#123;:15&#125; | &#123;:^9&#125; | &#123;:^9&#125;&#x27;</span>.format(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;lat.&#x27;</span>, <span class="string">&#x27;long.&#x27;</span>)) <span class="comment"># &quot;^9&quot; 代表占9个空格，内容居中对齐</span></span><br><span class="line">fmt = <span class="string">&#x27;&#123;:15&#125; | &#123;:9.4f&#125; | &#123;:9.4f&#125;&#x27;</span><span class="comment"># &#123;:15&#125;意思是占位15个空格，&#123;:9.4f&#125; 意思是占位9位空格，4位小数部分</span></span><br><span class="line"><span class="keyword">for</span> name, cc, pop, (latitude, longitude) <span class="keyword">in</span> metro_areas: <span class="comment"># ➋</span></span><br><span class="line"><span class="keyword">if</span> longitude &lt;= <span class="number">0</span>: <span class="comment"># ➌</span></span><br><span class="line">print(fmt.format(name, latitude, longitude))</span><br></pre></td></tr></table></figure>

<p>❶ 每个元组内有 4 个元素，其中最后一个元素是一对坐标。</p>
<p>❷ 我们把输入元组的最后一个元素拆包到由变量构成的元组里，这样<br>就获取了坐标。</p>
<p>❸ <code>if longitude &lt;= 0:</code> 这个条件判断把输出限制在西半球的城市。</p>
<p>示例 2-8 的输出是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">               |       lat. | long.</span><br><span class="line">Mexico City    |    <span class="number">19.4333</span> | <span class="number">-99.1333</span></span><br><span class="line">New York-Newark|    <span class="number">40.8086</span> | <span class="number">-74.0204</span></span><br><span class="line">Sao Paul       |   <span class="number">-23.5478</span> | <span class="number">-46.63</span></span><br></pre></td></tr></table></figure>

<p>在 Python 3 之前，元组可以作为形参放在函数声明中，例如def fn(a, (b, c), d):。然而 Python 3 不再支持这种格式，具体原因见于“PEP 3113—Removal of Tuple ParameterUnpacking”（<a target="_blank" rel="noopener" href="http://python.org/dev/peps/pep-3113/">http://python.org/dev/peps/pep-3113/</a>）。需要弄清楚的是，这个改变对函数调用者并没有影响，它改变的是某些函数的声明方式。</p>
<p>元组已经设计得很好用了，但作为记录来用的话，还是少了一个功能：我们时常会需要给记录中的字段命名。namedtuple 函数的出现帮我们解决了这个问题。</p>
<h3 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h3><p>collections.namedtuple 是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类——这个带名字的类对调试程序有很大帮助。</p>
<p>用 namedtuple 构建的类的实例所消耗的内存跟元组是一样的，因为字段名都被存在对应的类里面。这个实例跟普通的对象实例比起来也要小一些，因为 Python 不会用 <code>__dict__</code> 来存放这些实例的属性。</p>
<p>在第 1 章中，展示过这样一段代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Card = collections.namedtuple(<span class="string">&#x27;Card&#x27;</span>, [<span class="string">&#x27;rank&#x27;</span>, <span class="string">&#x27;suit&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>示例 2-9 展示了如何用具名元组来记录一个城市的信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>City = namedtuple(<span class="string">&#x27;City&#x27;</span>, <span class="string">&#x27;name country population coordinates&#x27;</span>) ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo = City(<span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)) ➋</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo</span><br><span class="line">City(name=<span class="string">&#x27;Tokyo&#x27;</span>, country=<span class="string">&#x27;JP&#x27;</span>, population=<span class="number">36.933</span>, coordinates=(<span class="number">35.689722</span>,</span><br><span class="line"><span class="number">139.691667</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo.population ➌</span><br><span class="line"><span class="number">36.933</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo.coordinates</span><br><span class="line">(<span class="number">35.689722</span>, <span class="number">139.691667</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;JP</span></span><br></pre></td></tr></table></figure>

<p>❶ 创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。后者可以是由数个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的字符串。</p>
<p>❷ 存放在对应字段里的数据要以一串参数的形式传入到构造函数中（注意，元组的构造函数却只接受单一的可迭代对象）。</p>
<p>❸ 你可以通过字段名或者位置来获取一个字段的信息。</p>
<p>除了从普通元组那里继承来的属性之外，具名元组还有一些自己专有的属性。示例 2-10 中就展示了几个最有用的：_fields 类属性、类方法_make(iterable) 和实例方法 _asdict()。</p>
<p>示例 2-10 具名元组的属性和方法（接续前一个示例）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>City._fields ➊</span><br><span class="line">(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;country&#x27;</span>, <span class="string">&#x27;population&#x27;</span>, <span class="string">&#x27;coordinates&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LatLong = namedtuple(<span class="string">&#x27;LatLong&#x27;</span>, <span class="string">&#x27;lat long&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>delhi_data = (<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, LatLong(<span class="number">28.613889</span>, <span class="number">77.208889</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>delhi = City._make(delhi_data) ➋</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>delhi._asdict() ➌</span><br><span class="line">OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Delhi NCR&#x27;</span>), (<span class="string">&#x27;country&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>), (<span class="string">&#x27;population&#x27;</span>,</span><br><span class="line"><span class="number">21.935</span>), (<span class="string">&#x27;coordinates&#x27;</span>, LatLong(lat=<span class="number">28.613889</span>, long=<span class="number">77.208889</span>))])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, value <span class="keyword">in</span> delhi._asdict().items():</span><br><span class="line">print(key + <span class="string">&#x27;:&#x27;</span>, value)</span><br><span class="line">name: Delhi NCR</span><br><span class="line">country: IN</span><br><span class="line">population: <span class="number">21.935</span></span><br><span class="line">coordinates: LatLong(lat=<span class="number">28.613889</span>, long=<span class="number">77.208889</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>❶ _fields 属性是一个包含这个类所有字段名称的元组。</p>
<p>❷ 用 _make() 通过接受一个可迭代对象来生成这个类的一个实例，它的作用跟 City(*delhi_data) 是一样的。</p>
<p>❸ _asdict() 把具名元组以 collections.OrderedDict 的形式返回，我们可以利用它来把元组里的信息友好地呈现出来。</p>
<p>现在我们知道了，元组是一种很强大的可以当作记录来用的数据类型。它的第二个角色则是充当一个不可变的列表。下面就来看看它的第二重功能。</p>
<h3 id="作为不可变列表的元组"><a href="#作为不可变列表的元组" class="headerlink" title="作为不可变列表的元组"></a>作为不可变列表的元组</h3><p>如果要把元组当作列表来用的话，最好先了解一下它们的相似度如何。在下表中可以清楚地看到，除了跟增减元素相关的方法之外，元组支持列表的其他所有方法。还有一个例外，元组没有 <code>__reversed__</code> 方法，但是这个方法只是个优化而已，reversed(my_tuple) 这个用法在没有 <code>__reversed__</code> 的情况下也是合法的。</p>
<p>列表或元组的方法和属性（那些由object类支持的方法没有列出来）：</p>
<table>
<thead>
<tr>
<th></th>
<th>列表</th>
<th>元组</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>s.__add__(s2)</code></td>
<td>*</td>
<td>*</td>
<td>s + s2，拼接</td>
</tr>
<tr>
<td><code>s.__iadd__(s2)</code></td>
<td>*</td>
<td></td>
<td>s += s2，就地拼接</td>
</tr>
<tr>
<td><code>s.append(e)</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.clear()</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.__contains__(e)</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.copy()</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.count(e)</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.__delitem__(p)</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.extend(it)</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.__getitem__(p)</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.__getnewargs__()</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.index(e)</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.insert(p, e)</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.__iter__()</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.__len__()</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.__mul__(n)</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.__imul__(n)</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.__rmul__(n)</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.pop([p])</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.remove(e)</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.reverse()</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.__reversed__()</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.__setitem__(p,e)</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.sort([key],[reverse])</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>每个 Python 程序员都知道序列可以用 s[a:b] 的形式切片，但是关于切片，我还想说说它的一些不太为人所知的方面。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/10/29/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84-2-2/" rel="prev" title="流畅的Python学习笔记-02序列构成的数组-2-2">
      <i class="fa fa-chevron-left"></i> 流畅的Python学习笔记-02序列构成的数组-2-2
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/03/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84-2-4/" rel="next" title="流畅的Python学习笔记-02序列构成的数组-2-4">
      流畅的Python学习笔记-02序列构成的数组-2-4 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%BB%84%E5%92%8C%E8%AE%B0%E5%BD%95"><span class="nav-number">1.</span> <span class="nav-text">元组和记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%83%E7%BB%84%E6%8B%86%E5%8C%85"><span class="nav-number">2.</span> <span class="nav-text">元组拆包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E5%85%83%E7%BB%84%E6%8B%86%E5%8C%85"><span class="nav-number">3.</span> <span class="nav-text">嵌套元组拆包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B7%E5%90%8D%E5%85%83%E7%BB%84"><span class="nav-number">4.</span> <span class="nav-text">具名元组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%9C%E4%B8%BA%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%88%97%E8%A1%A8%E7%9A%84%E5%85%83%E7%BB%84"><span class="nav-number">5.</span> <span class="nav-text">作为不可变列表的元组</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wu"
      src="/images/wu_avatar.png">
  <p class="site-author-name" itemprop="name">wu</p>
  <div class="site-description" itemprop="description">宇宙的尽头到底是什么</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
	
	
	  <!-- require APlayer -->
	  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
	  <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
      <!-- require MetingJS -->
	  <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
      <meting-js
		server="netease"
		type="playlist"
		id="3224891457"
		list-folded="true">
	  </meting-js>

	  
	  
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wu</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
