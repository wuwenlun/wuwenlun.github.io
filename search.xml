<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>InnoDB的一条记录长什么样子</title>
    <url>/2020/09/24/InnoDB%E7%9A%84%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E9%95%BF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>InnoDB的一条记录长什么样子</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028143018.png"></p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前文介绍了 MySQL 的基本架构，大体上可以分为「Server 层」和「存储引擎层」两部分。</p>
<p>其中存储引擎包括多种，它们存储数据的形式也不尽相同。有的存储引擎（比如 Memory 引擎）只把数据存储在内存、并不会持久化到磁盘，这样一旦服务器挂了，数据就没了。而默认的 InnoDB 引擎则会把数据持久化到磁盘中。</p>
<p>那么，我们插入的一条记录在 InnoDB 引擎中以什么格式存储的呢？本文进一步介绍和分析。</p>
<h2 id="InnoDB-记录格式"><a href="#InnoDB-记录格式" class="headerlink" title="InnoDB 记录格式"></a>InnoDB 记录格式</h2><h3 id="页"><a href="#页" class="headerlink" title="页"></a>页</h3><p>在分析 InnoDB 的行记录格式前，先简单介绍下「页」的概念。</p>
<p>InnoDB 将存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，一个页的大小默认为 16KB。可以通过下面命令查看默认页的大小（单位是字节）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status like &#x27;innodb_page_size&#x27;;</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| Variable_name    | Value |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">| Innodb_page_size | 16384 |</span><br><span class="line">+<span class="comment">------------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>也就是说，即便我们只查询一条记录，InnoDB 也会把至少 16KB 的内容从磁盘读到内存中。</p>
<h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><p>InnoDB 的行格式有四种，分别是 Compact、Redundant、Dynamic 和 Compressed，它们在原理上大体都是相同的。本文主要分析 Compact 格式。</p>
<p>可以使用下面命令查看默认行格式（此处 MySQL 版本为 5.7）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;innodb_default_row_format&#x27;;</span><br><span class="line">+<span class="comment">---------------------------+---------+</span></span><br><span class="line">| Variable_name             | Value   |</span><br><span class="line">+<span class="comment">---------------------------+---------+</span></span><br><span class="line">| innodb_default_row_format | dynamic |</span><br><span class="line">+<span class="comment">---------------------------+---------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">mysql&gt; <span class="keyword">SELECT</span> @@innodb_default_row_format;</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">| @@innodb_default_row_format |</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">| dynamic                     |</span><br><span class="line">+<span class="comment">-----------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>也可以在建表时指定行格式，或者建表后再修改。</p>
<p>Compact 行格式的结构大概如图所示：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924154248.jpg" alt="img"></p>
<p>主要分为两部分：记录的额外信息和记录的真实数据。下面分别介绍。</p>
<h3 id="额外信息"><a href="#额外信息" class="headerlink" title="额外信息"></a>额外信息</h3><p>为便于举例分析，这里先建一个表如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create table t1\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">       Table: t1</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">Table</span>: <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line">  <span class="string">`c1`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c2`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c3`</span> <span class="built_in">char</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`c4`</span> <span class="built_in">varchar</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=latin1</span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<h4 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h4><ul>
<li>概念说明</li>
</ul>
<p>MySQL 中有些类型的字段长度是不固定的，比如 VARCHAR(M) 类型、TEXT 等，这就导致每条记录中该字段的「实际」长度可能是不一样的。</p>
<p>为此，MySQL 在存储这些变长类型的数据时，实际上分成了两部分存储，分别是：</p>
<ol>
<li>真实的数据</li>
<li>数据占用的字节数</li>
</ol>
<p>其中数据占用的字节数就保存在「变长字段长度列表」中。它是以列的「逆序」存储表中变长字段的实际长度的。</p>
<ul>
<li>举例分析</li>
</ul>
<p>以上面的 t1 表为例，它的变长字段为 c1、c2、c4，若有一条数据如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t1;</span><br><span class="line">+<span class="comment">------+----+------+------+</span></span><br><span class="line">| c1   | c2 | c3   | c4   |</span><br><span class="line">+<span class="comment">------+----+------+------+</span></span><br><span class="line">| a    | bb | ccc  | dddd |</span><br><span class="line">+<span class="comment">------+----+------+------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>则这三个字段占用的字节数分别为：1、2、4，以「逆序」存放在变长字段长度列表为 040201（十六进制）。</p>
<blockquote>
<p>PS: 字节数跟字符集有关系，latin1 字符默认占用一个字节。 </p>
</blockquote>
<h4 id="NULL-值列表"><a href="#NULL-值列表" class="headerlink" title="NULL 值列表"></a>NULL 值列表</h4><ul>
<li>概念说明</li>
</ul>
<p>MySQL 中有些列是允许为 NULL 的，如果这些列很多、每个 NULL 值都在表中存储的话会很占用空间。Compact 把这些 NULL 统一管理了起来，放到了 NULL 值列表。</p>
<p>它的处理过程如下：</p>
<ol>
<li><p>统计表中允许为 NULL 的列</p>
</li>
<li><ol>
<li>若列都不允许为 NULL，则 NULL 值列表就不存在了；</li>
<li>否则，以一个「二进制位」来表示一个允许为空的列，仍是「逆序」排列，其中 1 表示 NULL，0 表示非 NULL </li>
</ol>
</li>
<li><p>若 NULL 值列表不足整数「字节」，在高位补 0</p>
</li>
</ol>
<ul>
<li>举例分析</li>
</ul>
<p>以上面 t1 表为例，c1、c3、c4 三列都允许为 NULL，则使用 3 位表示三个允许为空的列，不足一个字节（8 位），因此高 5 位补 0，如图所示：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924154247.jpg" alt="img"></p>
<p>再插入一条数据（’a’, ‘bb’, NULL, NULL）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t1;</span><br><span class="line">+<span class="comment">------+----+------+------+</span></span><br><span class="line">| c1   | c2 | c3   | c4   |</span><br><span class="line">+<span class="comment">------+----+------+------+</span></span><br><span class="line">| a    | bb | ccc  | dddd |</span><br><span class="line">| a    | bb | NULL | NULL |</span><br><span class="line">+<span class="comment">------+----+------+------+</span></span><br><span class="line">2 rows in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>

<p>由于第一条记录的字段都不是 NULL，因此它的 NULL 值列表为：0000 0000；</p>
<p>第二条记录的 c3、c4 列为 NULL，它的 NULL 值列表为：0000 0110。</p>
<h4 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h4><p>第三部分是记录头信息（个人觉得有点类似 JVM 中的对象头信息），该部分占用 5 个字节，示意图如下：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924154249.jpg" alt="img"></p>
<p>其中各个部分大概说明如下：</p>
<ul>
<li>前两个预留位：暂无用处（各占 1 位）</li>
<li>delete_mask：1 位，标记该条记录是否被删除</li>
<li>min_rec_mask：1位，B+树每层非叶子节点中的最小记录都会添加该标记</li>
<li>n_owned：4 位，当前记录拥有的记录数</li>
<li>heap_no：13 位，当前记录在记录堆的位置</li>
<li>record_type：3 位，记录的类型，记录分为多种类型，使用该位做区分</li>
<li>next_record：16 位，保存下一条记录的相对位置</li>
</ul>
<p>这些东西似乎有点多，其中大部分跟索引和页有关，后文再介绍页的时候再分析。</p>
<h3 id="真实数据"><a href="#真实数据" class="headerlink" title="真实数据"></a>真实数据</h3><p>总算到了真实的数据部分，但这部分其实也并非只有我们自定义的列，大体可分为两部分：隐藏列和自定义数据。</p>
<h4 id="隐藏列"><a href="#隐藏列" class="headerlink" title="隐藏列"></a>隐藏列</h4><p>这部分是 InnoDB 默认添加的列。主要包括三部分：</p>
<h5 id="row-id"><a href="#row-id" class="headerlink" title="row_id"></a>row_id</h5><p>真实名称为 DB_ROW_ID，表示行记录的唯一标识，这一列并不是必须的。</p>
<p>说起 row_id，有必要提一下 InnoDB 的主键生成策略，它遵循如下顺序：</p>
<ol>
<li>优先使用用户定义的主键</li>
<li>若未定义主键，则选取唯一键作为主键</li>
<li>若无唯一键，添加 row_id 作为主键</li>
</ol>
<p>即，当我们新建一个表时，若没有指定主键（Primary Key），InnoDB 会选择一个唯一键（Unique Key）作为主键，如果表中唯一键也没定义，则就要添加一个 row_id 来充当主键了。因为还要自己生成 id，这样会降低效率。</p>
<p>阿里巴巴的《Java开发手册》中有一条相关规定：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924154250.jpg" alt="img"></p>
<h5 id="transaction-id-amp-roll-pointer"><a href="#transaction-id-amp-roll-pointer" class="headerlink" title="transaction_id &amp; roll_pointer"></a>transaction_id &amp; roll_pointer</h5><p>transaction_id 的真实名称为 DB_TRX_ID，表示事务的 id；roll_pointer 真实名称为 DB_ROLL_PTR，表示回滚指针。</p>
<p>这二者都跟事务密切相关，而且都是必须的，后面再进行分析。</p>
<h3 id="我们自定义的数据列"><a href="#我们自定义的数据列" class="headerlink" title="我们自定义的数据列"></a>我们自定义的数据列</h3><p>这部分才是我们真正的自定义的列的数据，以 t1 表为例，就是我们定义的 c1、c2、c3、c4 这四列的数据，不再赘述。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/147387036">https://zhuanlan.zhihu.com/p/147387036</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>InnoDB</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL分组下最近的记录</title>
    <url>/2020/11/27/MySQL%E5%88%86%E7%BB%84%E4%B8%8B%E5%BE%97%E5%88%B0%E6%9C%80%E8%BF%91%E7%9A%84%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>找到分组条件下最近的一条数据</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201127163535.png"></p>
<a id="more"></a>

<p>对于不是很熟悉SQL的同学说，立马可能会想到排序后再<code>limit 1</code>就搞定了，看到数据后就开始反思了：“这才一条数据，这不是我想要的效果“。有的同学思前想后会写出来，我相信其他大部分同学肯定写不出来，对于这部分同学你们有福了。看了这个段落，就能解决你们的痛点。</p>
<h5 id="建立一张表"><a href="#建立一张表" class="headerlink" title="建立一张表"></a>建立一张表</h5><p>该表主要记录用户购买手机日期。我相信一个人在他的一生中肯定有购买手机的经历，有的人一生可能只有一部手机（当然这不太可能），有的人有多部手机。根据该表找到所有用户购买手机最近的记录。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> user_phone (</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment <span class="keyword">comment</span> <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">comment</span> <span class="string">&#x27;姓名&#x27;</span>,</span><br><span class="line">    phone <span class="built_in">varchar</span>(<span class="number">16</span>) <span class="keyword">comment</span> <span class="string">&#x27;手机型号&#x27;</span>,</span><br><span class="line">    buy_time datetime <span class="keyword">comment</span> <span class="string">&#x27;购买日期&#x27;</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_phone (<span class="keyword">name</span>, phone, buy_time) <span class="keyword">values</span> (<span class="string">&quot;吴文伦&quot;</span>, <span class="string">&quot;天语&quot;</span>, <span class="string">&quot;2006-07-12&quot;</span>), (<span class="string">&quot;吴文伦&quot;</span>, <span class="string">&quot;诺基亚&quot;</span>, <span class="string">&quot;2011-08-23&quot;</span>), (<span class="string">&quot;吴文伦&quot;</span>, <span class="string">&quot;中兴&quot;</span>, <span class="string">&quot;2015-04-08&quot;</span>), (<span class="string">&quot;吴文伦&quot;</span>, <span class="string">&quot;魅族&quot;</span>, <span class="string">&quot;2017-12-02&quot;</span>), (<span class="string">&quot;吴文伦&quot;</span>, <span class="string">&quot;红米&quot;</span>, <span class="string">&quot;2020-05-15&quot;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_phone (<span class="keyword">name</span>, phone, buy_time) <span class="keyword">values</span> (<span class="string">&quot;勒布朗&quot;</span>, <span class="string">&quot;大哥大&quot;</span>, <span class="string">&quot;1995-09-16&quot;</span>), (<span class="string">&quot;勒布朗&quot;</span>, <span class="string">&quot;诺基亚&quot;</span>, <span class="string">&quot;2001-03-22&quot;</span>), (<span class="string">&quot;勒布朗&quot;</span>, <span class="string">&quot;苹果1代&quot;</span>, <span class="string">&quot;2007-06-08&quot;</span>), (<span class="string">&quot;勒布朗&quot;</span>, <span class="string">&quot;苹果5代&quot;</span>, <span class="string">&quot;2013-11-09&quot;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> user_phone (<span class="keyword">name</span>, phone, buy_time) <span class="keyword">values</span> (<span class="string">&quot;老于&quot;</span>, <span class="string">&quot;土砖&quot;</span>, <span class="string">&quot;1994-01-01&quot;</span>), (<span class="string">&quot;老于&quot;</span>, <span class="string">&quot;华为&quot;</span>, <span class="string">&quot;2003-08-09&quot;</span>), (<span class="string">&quot;老于&quot;</span>, <span class="string">&quot;vivo&quot;</span>, <span class="string">&quot;2009-07-08&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>数据列表如下：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201127172045.png"></p>
<p>如何操作才能找到符合业务要求的数据呢？正确数据如下：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201127174105.png"></p>
<p>——————————————————————————–华丽的分界线—————————————————————————————-</p>
<h5 id="分组原理"><a href="#分组原理" class="headerlink" title="分组原理"></a>分组原理</h5><p>表里面有三个人，故应想到对<code>name</code>进行分组，分组后能够得到<font color=red><strong>子数据列表项</strong></font>，然后根据聚合函数<code>max</code>在<font color=red><strong>子数据列表项</strong></font>中找到<code>buy_time</code>这一列中最大的日期的那一个值。聚合函数的作用就是在一堆列表数据里的指定列进行聚合运算合成一个值，注意它只针对字段列。<img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201208200558.png"></p>
<p>执行该SQL语句会得到如下数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">max</span>(buy_time) <span class="keyword">as</span> buy_time <span class="keyword">from</span> user_phone <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201209195825.png"></p>
<p>但是少了id和phone两个字段，很多人可能会想到这样子做：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, phone, <span class="keyword">max</span>(buy_time) <span class="keyword">as</span> buy_time <span class="keyword">from</span> user_phone <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure>

<p>那我们执行以下，结果报错了！！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR 1055 (42000): Expression #1 of SELECT list is not in GROUP BY clause and contains nonaggregated column &#39;wuwenlun.user_phone.id&#39; which is not functionally dependent on columns in GROUP BY clause; this is incompatible with sql_mode&#x3D;only_full_group_by</span><br></pre></td></tr></table></figure>

<p>意思是说<code>sql_mode</code>为<code>only_full_group_by</code>，字段中只允许展示分组的那些字段，在本例中即为<code>name</code>，<code>id</code>和<code>phone</code>不允许展示。如果需要展示，就需要改<code>sql_mode</code>，把<code>only_full_group_by</code>去掉。下面的语句中已经没有<code>only_full_group_by</code>了，执行它。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> @@session.sql_mode = <span class="string">&#x27;STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION&#x27;</span></span><br></pre></td></tr></table></figure>

<p>再执行查询语句，看看结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>, <span class="keyword">name</span>, phone, <span class="keyword">max</span>(buy_time) <span class="keyword">as</span> buy_time <span class="keyword">from</span> user_phone <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201209201457.png"></p>
<p>虽然可以执行了，但/并不是我们想要的结果（所有用户最近购买手机的记录），为什么名字为<code>吴文伦</code>的这条记录id为1？就得通过分组的运行机理去分析。根据name分组后找到<code>吴文伦</code>的第一条记录，它是根据记录在表中顺序找到第一个得到的。所以id为<code>1</code>，phone为<code>天语</code>是这样子得到的。</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201209202925.png"></p>
<p>所以，明白机理后，要得到正确答案就很容易了，先倒排序再分组就可以了，这样子最近的记录会排在最前面。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t.* <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> user_phone <span class="keyword">order</span> <span class="keyword">by</span> buy_time <span class="keyword">desc</span>) <span class="keyword">as</span> t <span class="keyword">group</span> <span class="keyword">by</span> t.name;</span><br></pre></td></tr></table></figure>

<p>卧槽，咋还是不对呢？没有起到任何效果！这是因为外层查询是group by，mysql会把子查询里的order by当做无效处理了，对group by来说它只关注结果集，跟你排不排序没有关系，所以在sql优化过程中就把子查询排序省略了，毕竟排序是会耗时间和资源的。</p>
<p>那如何让分组group by情况下分组不失效呢？全网几乎一致的说后面补上limit去影响结果集，语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t.* <span class="keyword">from</span> (<span class="keyword">select</span> * <span class="keyword">from</span> user_phone <span class="keyword">order</span> <span class="keyword">by</span> buy_time <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">9999999</span>) <span class="keyword">as</span> t <span class="keyword">group</span> <span class="keyword">by</span> t.name;</span><br></pre></td></tr></table></figure>

<p>可以得到正确输出：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201212140226.png"></p>
<p>但是我总觉得这种操作有点变态，我想着换一种方法，就是先分组得到用户名和该用户最近购买手机的日期这两个值，以此为查询条件再回表查询。语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t.* <span class="keyword">from</span> user_phone t <span class="keyword">where</span> (t.name, t.buy_time) <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">name</span>, <span class="keyword">max</span>(buy_time) <span class="keyword">as</span> buy_time <span class="keyword">from</span> user_phone <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">name</span>);</span><br></pre></td></tr></table></figure>

<p>依然能够得到正确答案：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201127174105.png"></p>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>InnoDB一棵B+树可以存放多少行数据</title>
    <url>/2020/09/24/InnoDB%E4%B8%80%E6%A3%B5B+%E6%A0%91%E5%8F%AF%E4%BB%A5%E5%AD%98%E6%94%BE%E5%A4%9A%E5%B0%91%E8%A1%8C%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>InnoDB一棵<code>B+</code>树可以存放多少行数据</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028143018.png"></p>
<a id="more"></a>

<h3 id="InnoDB-一棵-B-树可以存放多少行数据？"><a href="#InnoDB-一棵-B-树可以存放多少行数据？" class="headerlink" title="InnoDB 一棵 B+ 树可以存放多少行数据？"></a>InnoDB 一棵 B+ 树可以存放多少行数据？</h3><p>InnoDB 一棵 B+ 树可以存放多少行数据？</p>
<p>这个问题的简单回答是：<strong>约 2 千万</strong>。为什么是这么多呢？</p>
<p>因为这是可以算出来的，要搞清楚这个问题，我们先从 InnoDB 索引数据结构、数据组织方式说起。我们都知道计算机在存储数据的时候，有<strong>最小存储单元</strong>，这就好比我们今天进行现金的流通最小单位是一毛。</p>
<p>在计算机中磁盘存储数据最小单元是扇区，一个扇区的大小是 512 字节，而文件系统（例如XFS/EXT4）他的最小单元是块，一个块的大小是 4k，而对于我们的 InnoDB 存储引擎也有自己的最小储存单元——页（Page），一个页的大小是 16K。</p>
<h3 id="下面几张图可以帮你理解最小存储单元"><a href="#下面几张图可以帮你理解最小存储单元" class="headerlink" title="下面几张图可以帮你理解最小存储单元"></a>下面几张图可以帮你理解最小存储单元</h3><p>文件系统中一个文件大小只有1个字节，但不得不占磁盘上4KB的空间。</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924162126.jpg" alt="img"></p>
<p>Innodb 的所有数据文件（后缀为 ibd 的文件），他的大小始终都是 16384（16k）的整数倍。</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924162133.jpg" alt="img"></p>
<p>磁盘扇区、文件系统、InnoDB 存储引擎都有各自的最小存储单元。</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924162137.jpg" alt="img"></p>
<p>在 MySQL 中我们的 <strong>InnoDB 页的大小默认是 16k</strong>，当然也可以通过参数设置：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924162145.jpg" alt="img"></p>
<p>数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？</p>
<p>假设一行数据的大小是 1k，那么一个页可以存放 16 行这样的数据。</p>
<p>如果数据库只按这样的方式存储，那么如何查找数据就成为一个问题，因为我们不知道要查找的数据存在哪个页中，也不可能把所有的页遍历一遍，那样太慢了。</p>
<p>所以人们想了一个办法，用 B+ 树的方式组织这些数据。如图所示：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924162151.jpg" alt="img"></p>
<p>我们先将数据记录按主键进行排序，分别存放在不同的页中（为了便于理解我们这里一个页中只存放 3 条记录，实际情况可以存放很多），<strong>除了存放数据的页以外，还有存放键值+指针的页</strong>，如图中page number=3 的页，该页存放键值和指向数据页的指针，这样的页由 N 个键值 + 指针组成。</p>
<p><strong>当然它也是排好序的</strong>。</p>
<p>这样的数据组织形式，我们称为索引组织表。</p>
<p>现在来看下，要查找一条数据，怎么查？</p>
<p>如 select * from user where id=5;</p>
<p>这里 id 是主键，我们通过这棵 B+ 树来查找，<strong>首先找到根页</strong>，你怎么知道 user 表的根页在哪呢？</p>
<p>其实每张表的根页位置在表空间文件中是固定的，即 page number=3 的页（这点我们下文还会进一步证明），找到根页后通过二分查找法，定位到 id=5 的数据应该在指针 P5 指向的页中，那么进一步去 page number=5 的页中查找，同样通过二分查询法即可找到 id=5 的记录：</p>
<p>| 5 | zhao2 | 27 |</p>
<p>现在我们清楚了 InnoDB 中主键索引 B+ 树是如何组织数据、查询数据的，我们总结一下：</p>
<p>1、InnoDB 存储引擎的<strong>最小存储单元是页</strong>，页可以用于<strong>存放数据</strong>也可以用于<strong>存放键值 + 指针</strong>，在 B+ 树中叶子节点存放数据，非叶子节点存放键值 + 指针。</p>
<p>2、<strong>索引组织表</strong>通过<strong>非叶子节点</strong>的<strong>二分查找法以及指针</strong>确定数据在哪个页中，进而在去数据页中查找到需要的数据；</p>
<h3 id="那么回到我们开始的问题，通常一棵-B-树可以存放多少行数据？"><a href="#那么回到我们开始的问题，通常一棵-B-树可以存放多少行数据？" class="headerlink" title="那么回到我们开始的问题，通常一棵 B+ 树可以存放多少行数据？"></a>那么回到我们开始的问题，通常一棵 B+ 树可以存放多少行数据？</h3><p>这里我们先假设 B+ 树高为 2，即存在一个根节点和若干个叶子节点，那么这棵 B+ 树的存放总记录数为：根节点指针数 * 单个叶子节点记录行数。</p>
<p>上文我们已经说明单个叶子节点（页）中的记录数 =16K/1K=16。（这里假设一行记录的数据大小为 1k，实际上现在很多互联网业务数据记录大小通常就是 1K 左右）。</p>
<p>那么现在我们需要计算出非叶子节点能存放多少指针？</p>
<p>其实这也很好算，我们假设主键 ID 为 bigint 类型，长度为 8 字节，而指针大小在 InnoDB 源码中设置为 6 字节，这样一共 14 字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即 16384/14=1170。</p>
<p>那么可以算出一棵高度为 2 的 B+ 树，能存放 1170*16=18720 条这样的数据记录。</p>
<p>根据同样的原理我们可以算出一个高度为 3 的 B+ 树可以存放： 1170<em>1170</em>16=21902400 条这样的记录。</p>
<p><strong>所以在 InnoDB 中 B+ 树高度一般为 1-3 层，它就能满足千万级的数据存储</strong>。</p>
<p>在查找数据时一次页的查找代表一次 IO，所以通过主键索引查询通常只需要 1-3 次 IO 操作即可查找到数据。</p>
<h3 id="怎么得到-InnoDB-主键索引-B-树的高度？"><a href="#怎么得到-InnoDB-主键索引-B-树的高度？" class="headerlink" title="怎么得到 InnoDB 主键索引 B+ 树的高度？"></a>怎么得到 InnoDB 主键索引 B+ 树的高度？</h3><p>上面我们通过推断得出 B+ 树的高度通常是 1-3，下面我们从另外一个侧面证明这个结论。</p>
<p>在 InnoDB 的表空间文件中，约定 page number为 3 的代表主键索引的根页，而在根页偏移量为 64 的地方存放了该 B+ 树的 page level。</p>
<p>如果 page level 为 1，树高为 2，page level 为 2，则树高为 3。</p>
<p>即 B+ 树的高度 =page level+1；</p>
<p>下面我们将从实际环境中尝试找到这个 page level。</p>
<p>在实际操作之前，你可以通过 InnoDB 元数据表确认主键索引根页的 page number 为 3，你也可以从《InnoDB 存储引擎》这本书中得到确认。</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924162156.jpg" alt="img"></p>
<p>执行结果：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924162201.jpg" alt="img"></p>
<p>可以看出数据库 dbt3 下的 customer 表、lineitem 表主键索引根页的 page number 均为 3，而其他的二级索引 page number 为 4。</p>
<p>关于二级索引与主键索引的区别请参考 MySQL 相关书籍，本文不在此介绍。</p>
<p>下面我们对数据库表空间文件做想相关的解析：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924162206.jpg" alt="img"></p>
<p>因为主键索引 B+ 树的根页在整个表空间文件中的第 3 个页开始，所以可以算出它在文件中的偏移量：16384*3=49152（16384 为页大小）。</p>
<p>另外根据《InnoDB 存储引擎》中描述在根页的 64 偏移量位置前 2 个字节，保存了 page level 的值，因此我们想要的 page level 的值在整个文件中的偏移量为：16384*3+64=49152+64=49216，前 2 个字节中。</p>
<p>接下来我们用 hexdump 工具，查看表空间文件指定偏移量上的数据：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924162215.jpg" alt="img"></p>
<p>linetem 表的 page level 为 2，B+ 树高度为 page level+1=3；</p>
<p>region 表的 page level 为 0，B+ 树高度为 page level+1=1；</p>
<p>customer 表的 page level 为 2，B+ 树高度为 page level+1=3；</p>
<p>这三张表的数据量如下：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924162221.jpg" alt="img"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>lineitem 表的数据行数为 600 多万，B+ 树高度为 3，customer 表数据行数只有 15 万，B+ 树高度也为 3。</p>
<p>可以看出尽管数据量差异较大，这两个表树的高度都是 3，换句话说<strong>这两个表通过索引查询效率并没有太大差异，因为都只需要做 3 次 IO</strong>。</p>
<p>那么如果有一张表行数是一千万，那么他的 B+ 树高度依旧是 3，查询效率仍然不会相差太大。</p>
<p>region 表只有 5 行数据，当然他的 B+ 树高度为 1。</p>
<h3 id="最后回顾一道面试题"><a href="#最后回顾一道面试题" class="headerlink" title="最后回顾一道面试题"></a>最后回顾一道面试题</h3><p>有一道 MySQL 的面试题，为什么 MySQL 的索引要使用 B+ 树而不是其它树形结构？</p>
<p>比如 B 树？</p>
<p>现在这个问题的复杂版本可以参考本文；</p>
<p>他的简单版本回答是：</p>
<p><strong>因为 B 树不管叶子节点还是非叶子节点，都会保存数据</strong>，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文从一个问题出发，逐步介绍了 InnoDB 索引组织表的原理、查询方式，并结合已有知识，回答该问题，结合实践来证明。</p>
<p>当然为了表述简单易懂，文中忽略了一些细枝末节，比如<strong>一个页中不可能所有空间都用于存放数据</strong>，它还会存放一些少量的其他字段比如 page level，index number 等等，另外还有页的填充因子也导致一个页不可能全部用于保存数据。</p>
<p>关于二级索引数据存取方式可以参考 MySQL 相关书籍，他的要点是结合主键索引进行回表查询。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/67982911">https://zhuanlan.zhihu.com/p/67982911</a></li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
        <category>InnoDB</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap的死循环</title>
    <url>/2020/09/22/HashMap%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>HashMap死循环解析</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028142523.png"></p>
<a id="more"></a>

<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>最近的几次面试中，我都问了是否了解HashMap在并发使用时可能发生死循环，导致cpu100%，结果让我很意外，都表示不知道有这样的问题，让我意外的是面试者的工作年限都不短。</p>
<p>由于HashMap并非是线程安全的，所以在高并发的情况下必然会出现问题，这是一个普遍的问题，虽然网上分析的文章很多，还是觉得有必须写一篇文章，让关注我公众号的同学能够意识到这个问题，并了解这个死循环是如何产生的。</p>
<p>如果是在单线程下使用HashMap，自然是没有问题的，如果后期由于代码优化，这段逻辑引入了多线程并发执行，在一个未知的时间点，会发现CPU占用100%，居高不下，通过查看堆栈，你会惊讶的发现，线程都Hang在hashMap的get()方法上，服务重启之后，问题消失，过段时间可能又复现了。</p>
<p>这是为什么？</p>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>在了解来龙去脉之前，我们先看看HashMap的数据结构。</p>
<p>在内部，HashMap使用一个Entry数组保存key、value数据，当一对key、value被加入时，会通过一个hash算法得到数组的下标index，算法很简单，根据key的hash值，对数组的大小取模 hash &amp; (length-1)，并把结果插入数组该位置，如果该位置上已经有元素了，就说明存在hash冲突，这样会在index位置生成链表。</p>
<p>如果存在hash冲突，最惨的情况，就是所有元素都定位到同一个位置，形成一个长长的链表，这样get一个值时，最坏情况需要遍历所有节点，性能变成了O(n)，所以元素的hash值算法和HashMap的初始化大小很重要。</p>
<p>当插入一个新的节点时，如果不存在相同的key，则会判断当前内部元素是否已经达到阈值（默认是数组大小的0.75），如果已经达到阈值，会对数组进行扩容，也会对链表中的元素进行rehash。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>HashMap的put方法实现：</p>
<p>1、判断key是否已经存在</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(<span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 如果key已经存在，则替换value，并返回旧值</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.<span class="keyword">equals</span>(k))) &#123;</span><br><span class="line">            V oldValue = e.<span class="keyword">value</span>;</span><br><span class="line">            e.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// key不存在，则插入新的元素</span></span><br><span class="line">    addEntry(hash, key, <span class="keyword">value</span>, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、检查容量是否达到阈值threshold</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span>(<span class="params"><span class="keyword">int</span> hash, K key, V <span class="keyword">value</span>, <span class="keyword">int</span> bucketIndex</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="literal">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        hash = (<span class="literal">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createEntry(hash, key, <span class="keyword">value</span>, bucketIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果元素个数已经达到阈值，则扩容，并把原来的元素移动过去。</p>
<p>3、扩容实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    ...</span><br><span class="line">    transfer(newTable, rehash);</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里会新建一个更大的数组，并通过transfer方法，移动元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>移动的逻辑也很清晰，遍历原来table中每个位置的链表，并对每个元素进行重新hash，在新的newTable找到归宿，并插入。</p>
<h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><p>假设HashMap初始化大小为4，插入个3节点，不巧的是，这3个节点都hash到同一个位置，如果按照默认的负载因子的话，插入第3个节点就会扩容，为了验证效果，假设负载因子是1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable, <span class="keyword">boolean</span> rehash)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (rehash) &#123;</span><br><span class="line">                e.hash = <span class="keyword">null</span> == e.key ? <span class="number">0</span> : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是节点移动的相关逻辑。</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924150838.png" alt="img"></p>
<p>插入第4个节点时，发生rehash，假设现在有两个线程同时进行，线程1和线程2，两个线程都会新建新的数组。</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924150848.png" alt="img"></p>
<p>假设 <strong>线程2</strong> 在执行到<code>Entry&lt;K,V&gt; next = e.next;</code>之后，cpu时间片用完了，这时变量e指向节点a，变量next指向节点b。</p>
<p><strong>线程1</strong>继续执行，很不巧，a、b、c节点rehash之后又是在同一个位置7，开始移动节点</p>
<p>第一步，移动节点a</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924151112.png" alt="img"></p>
<p>第二步，移动节点b</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924151123.png" alt="img"></p>
<p>注意，这里的顺序是反过来的，继续移动节点c</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924151136.png" alt="img"></p>
<p>这个时候 <strong>线程1</strong> 的时间片用完，内部的table还没有设置成新的newTable， <strong>线程2</strong> 开始执行，这时内部的引用关系如下：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924151323.png" alt="img"></p>
<p>这时，在 <strong>线程2</strong> 中，变量e指向节点a，变量next指向节点b，开始执行循环体的剩余逻辑。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">Entry&lt;K,V&gt; <span class="keyword">next</span> = e.<span class="keyword">next</span>;</span><br><span class="line">int i = indexFor(e.hash, newCapacity);</span><br><span class="line">e.<span class="keyword">next</span> = newTable[i];</span><br><span class="line">newTable[i] = e;</span><br><span class="line">e = <span class="keyword">next</span>;</span><br></pre></td></tr></table></figure>

<p>执行之后的引用关系如下图</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924151336.png" alt="img"></p>
<p>执行后，变量e指向节点b，因为e不是null，则继续执行循环体，执行后的引用关系</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924151345.png" alt="img"></p>
<p>变量e又重新指回节点a，只能继续执行循环体，这里仔细分析下：<br> 1、执行完<code>Entry&lt;K,V&gt; next = e.next;</code>，目前节点a没有next，所以变量next指向null；<br> 2、<code>e.next = newTable[i];</code> 其中 newTable[i] 指向节点b，那就是把a的next指向了节点b，这样a和b就相互引用了，形成了一个环；<br> 3、<code>newTable[i] = e</code> 把节点a放到了数组i位置；<br> 4、<code>e = next;</code> 把变量e赋值为null，因为第一步中变量next就是指向null；</p>
<p>所以最终的引用关系是这样的：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924151356.png" alt="img"></p>
<p>节点a和b互相引用，形成了一个环，当在数组该位置get寻找对应的key时，就发生了死循环。</p>
<p>另外，如果线程2把newTable设置成到内部的table，节点c的数据就丢了，看来还有数据遗失的问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>所以在并发的情况，发生扩容时，可能会产生循环链表，在执行get的时候，会触发死循环，引起CPU的100%问题，所以一定要避免在并发环境下使用HashMap。</p>
<p>曾经有人把这个问题报给了Sun，不过Sun不认为这是一个bug，因为在HashMap本来就不支持多线程使用，要并发就用ConcurrentHashmap。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python学习笔记-01数据模型-1-1</title>
    <url>/2020/10/22/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-1-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>第一章第一节：一摞Python风格的纸牌</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028144038.png"></p>
<a id="more"></a>

<h3 id="一摞Python风格的纸牌"><a href="#一摞Python风格的纸牌" class="headerlink" title="一摞Python风格的纸牌"></a>一摞Python风格的纸牌</h3><p>下面这段程序是用来构建一副扑克牌，带红星、黑桃、方块、梅花的<code>23456789JQKA</code>牌，共<code>52</code>张</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">&quot;Card&quot;</span>, [<span class="string">&#x27;rank&#x27;</span>, <span class="string">&#x27;suit&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    ranks = [str(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">11</span>)] + list(<span class="string">&#x27;JQKA&#x27;</span>)</span><br><span class="line">    suits = <span class="string">&#x27;spades diamonds clubs hearts&#x27;</span>.split()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 左边第一个for循环是外层，第二个for循环是内层，可遍历_cards看数据的顺序得到</span></span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> len(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, position</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">for</span> card <span class="keyword">in</span> self._cards:</span><br><span class="line">            <span class="keyword">if</span> card == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>自<code>Python 2.6</code> 开始，<code>namedtuple</code>就加入到<code>Python</code>里，用以构建只有少数属性但是没有方法的对象。</p>
<p>当然，我们这个例子主要还是关注<code>FrenchDeck</code>这个类，它既短小又精悍。首先，它跟任何标准<code>Python</code>集合类型一样，可以用<code>len()</code> 函数来查看一叠牌有多少张。实际上<code>len()</code>函数调用的是<code>FrenchDeck</code>类的<code>__len__</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deck = FrenchDeck()</span><br><span class="line">print(len(deck))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="number">52</span></span><br></pre></td></tr></table></figure>

<p><code>__getitem()</code>方法也是非常有用处，可以得到特定的一张纸牌，如：<code>deck[0]</code>、<code>deck[1]</code>，还支持切片(<code>slicing</code>)操作。上述操作其内部逻辑就是去执行<code>__getitem__()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deck[:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;[Card(rank=<span class="string">&#x27;2&#x27;</span>, suit=<span class="string">&#x27;spades&#x27;</span>), Card(rank=<span class="string">&#x27;3&#x27;</span>, suit=<span class="string">&#x27;spades&#x27;</span>), Card(rank=<span class="string">&#x27;4&#x27;</span>, suit=<span class="string">&#x27;spades&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<p>另外，仅仅实现了<code>__getitem__</code>方法，这一摞牌就变成可迭代的了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">deck = FrenchDeck()</span><br><span class="line"><span class="keyword">for</span> card <span class="keyword">in</span> deck:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>反向迭代也没关系：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> card <span class="keyword">in</span> reversed(deck):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p><code>in</code>关键字在集合类型中除了支持遍历，还可以判断一个对象是否在该集合中，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(Card(<span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;hearts&#x27;</span>) <span class="keyword">in</span> deck)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>它工作的原理是判断该集合类是否实现了<code>__contains__</code>方法，如果实现了就用<code>__contains__</code>方法来判断一个对象是否在集合中，如果没有实现<code>__contains__</code>方法，就一个个遍历去调用<code>__getitem__</code>方法。</p>
<p>提问：</p>
<p>按照目前的设计，<code>FrenchDeck</code> 是不能洗牌的，因为这摞牌是不可变的（<code>immutable</code>）：卡牌和它们的位置都是固定的，除非我们破坏<br>这个类的封装性，直接对<code>_cards</code>进行操作。第<code>11</code>章会讲到，其实只需要一行代码来实现 <code>__setitem__</code> 方法，洗牌功能就不是问题了。</p>
]]></content>
      <categories>
        <category>流畅的Python</category>
        <category>第一章 Python的数据模型</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python学习笔记-01数据模型-1-5</title>
    <url>/2020/10/28/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-1-5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>第一章第五节：本章小结以及延申阅读</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028144038.png"></p>
<a id="more"></a>

<h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>通过实现特殊方法，自定义数据类型可以表现得跟内置类型一样，从而让我们写出更具表达力的代码——或者说，更具 Python 风格的代码。</p>
<p>Python 对象的一个基本要求就是它得有合理的字符串表示形式，我们可以通过 <code>__repr__</code> 和 <code>__str__</code> 来满足这个要求。前者方便我们调试和记录日志，后者则是给终端用户看的。这就是数据模型中存在特殊方法 <code>__repr__</code> 和 <code>__str__</code> 的原因。</p>
<p>对序列数据类型的模拟是特殊方法用得最多的地方，这一点在FrenchDeck 类的示例中有所展现。在第 2 章中，我们会着重介绍序列数据类型，然后在第 10 章中，我们会把 Vector 类扩展成一个多维的数据类型，通过这个练习你将有机会实现自定义的序列。</p>
<p>Python 通过<strong>运算符重载</strong>这一模式提供了丰富的数值类型，除了内置的那些之外，还有 <code>decimal.Decimal</code> 和 <code>fractions.Fraction</code>。这些数据类型都支持中缀算术运算符。在第 13 章中，我们还会通过对 Vector类的扩展来学习如何实现这些运算符，当然还会提到如何让运算符满足交换律和增强赋值。</p>
<p>Python 数据模型的特殊方法还有很多，本书会涵盖其中的绝大部分，探讨如何使用和实现它们。</p>
<h3 id="延申阅读"><a href="#延申阅读" class="headerlink" title="延申阅读"></a>延申阅读</h3><p>对本章内容和本书主题来说，Python 语言参考手册里的“Data Model”一章（<a href="https://docs.python.org/3/reference/datamodel.html">https://docs.python.org/3/reference/datamodel.html</a>）是最符合规范的知识来源。</p>
<p>Alex Martelli 的《Python 技术手册（第 2 版）》对数据模型的讲解很精彩。我写这本书的时候，《Python 技术手册》的最新版本是 2006 年出版的，书里用的还是 Python 2.5，但是 Python 关于数据模型的概念并没有太大的变化，而书中 Martelli 对属性访问机制的描述，应该是除了CPython 中的 C 源码之外在这方面最权威的解释。Martelli 还是 StackOverflow 上的高产贡献者，在他名下差不多有 5000 条答案，你也可以去他的 StackOverflow 主页（<a href="http://stackoverflow.com/users/95810/alex-martelli">http://stackoverflow.com/users/95810/alex-martelli</a>）上看看。</p>
<center>杂谈</center>

<p>数据模型还是对象模型：</p>
<p>Python 文档里总是用“Python 数据模型”这种说法，而大多数作者提到这个概念的时候会说“Python 对象模型”。Alex Martelli 的《Python技术手册（第 2 版）》和 David Beazley 的《Python 参考手册（第 4版）》是这个领域中最好的两本书，但是他们也总说“Python 对象模型”。维基百科中对象模型的第一个定义（<a href="http://en.wikipedia.org/wiki/Object_model">http://en.wikipedia.org/wiki/Object_model</a>）是：计算机编程语言中对象的属性。这正好是“Python 数据模型”所要描述的概念。我在本书中一直都会用“数据模型”这个词，首先是因为在 Python 文档里对这个词有偏爱，另外一个原因是 Python 语言参考手册中与这里讨论的内容最相关的一章的标题就是“数据模型”（<a href="https://docs.python.org/3/reference/datamodel.html">https://docs.python.org/3/reference/datamodel.html</a>）。</p>
<p>魔术方法：</p>
<p>在 Ruby 中也有类似“特殊方法”的概念，但是 Ruby 社区称之为“魔术方法”，而实际上 Python 社区里也有不少人用的是后者。而我恰恰认为“特殊方法”是“魔术方法”的对立面。Python 和 Ruby 都利用了这个概念来提供丰富的元对象协议，这不是魔术，而是让语言的用户和核心开发者拥有并使用同样的工具。考虑一下 JavaScript，情况就正好反过来了。JavaScript 中的对象有不透明的魔术般的特性，而你无法在自定义的对象中模拟这些行为。比如在 JavaScript 1.8.5 中，用户的自定义对象不能有只读属性，然而不少 JavaScript 的内置对象却可以有。因此在 JavaScript中，只读属性是“魔术”般的存在，对于普通的 JavaScript 用户而言，它就像超能力一样。2009 年推出的 ECMAScript 5.1 才让用户可以定义只读属性。JavaScript 中跟元对象协议有关的部分一直在进化，但由于历史原因，这方面它还是赶不上 Python 和 Ruby。</p>
<p>元对象：</p>
<p><code>The Art of the Metaobject Protocal （AMOP）</code>是我最喜欢的计算机图书的标题。客观来说，元对象协议这个词对我们学习Python 数据模型是有帮助的。元对象所指的是那些对建构语言本身来讲很重要的对象，以此为前提，协议也可以看作接口。也就是说，元对象协议是对象模型的同义词，它们的意思都是构建核心语言的 API。一套丰富的元对象协议能让我们对语言进行扩展，让它支持新的编程范式。AMOP 的第一作者 Gregor Kiczales 后来成为面向方面编程的先驱，他写出了一个 Java 扩展叫 AspectJ，用来实现他对面向方面编程的理念。其实在 Python 这样的动态语言里，更容易实现面向方面编程。现在已经有几个 Python 框架在做这件事情了，其中最重要的是 <code>zope.interface</code>（<a href="http://docs.zope.org/zope.interface/">http://docs.zope.org/zope.interface/</a>）。第11 章的延伸阅读里会谈到它。</p>
]]></content>
      <categories>
        <category>流畅的Python</category>
        <category>第一章 Python的数据模型</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python学习笔记-01数据模型-1-2</title>
    <url>/2020/10/22/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-1-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>第一章第二节：如何使用特殊方法</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028144038.png"></p>
<a id="more"></a>

<h3 id="如何使用特殊方法"><a href="#如何使用特殊方法" class="headerlink" title="如何使用特殊方法"></a>如何使用特殊方法</h3><p>首先明确一点，特殊方法的存在是为了被<code>Python</code>解释器调用的，你自己并不需要调用它们。也就是说没有<code>my_object.__len__()</code>这种写法，而应该使用<code>len(my_object)</code>。在执行<code>len(my_object)</code>的时候，如果<code>my_object</code>是一个自定义类的对象，那么<code>Python</code>会自己去调用其中由你实现的<code>__len__</code>方法。</p>
<p>然而如果是<code>Python</code>内置的类型，比如列表（<code>list</code>）、字符串（<code>str</code>）、字节序列（<code>bytearray</code>）等，那么<code>CPython</code>会抄个近路，<code>__len__</code> 实际上会直接返回<code>PyVarObject</code>里的<code>ob_size</code>属性。<code>PyVarObject</code>是表示内存中长度可变的内置对象的<code>C </code>语言结构体。直接读取这个值比调一个方法要快很多。</p>
<p>很多时候，特殊方法的调用是隐式的，比如<code>for i in x:</code>这个语句，背后其实用的是<code>iter(x)</code>，而这个函数的背后则是<code>x.__iter__()</code> 方法。当然前提是这个方法在<code>x</code>中被实现了。</p>
<p>通常你的代码无需直接使用特殊方法，除非有大量的元编程存在。唯一的例外可能是<code>__init__ </code>方法，你的代码里可能经常会用到它，目的是在你自己的子类的<code>__init__ </code>方法中调用超类的构造器。</p>
<p>通过内置的函数（例如<code>len</code>、<code>iter</code>、<code>str</code>，等等）来使用特殊方法是最好的选择。这些内置函数不仅会调用特殊方法，通常还提供额外的好处，而且对于内置的类来说，它们的速度更快。<code>14.12</code> 节中有详细的例子。不要自己想当然地随意添加特殊方法，比如<code>__foo__</code>之类的，因为现在这个名字没有被<code>Python</code>内部使用。</p>
<h4 id="模拟数值类型"><a href="#模拟数值类型" class="headerlink" title="模拟数值类型"></a>模拟数值类型</h4><p>利用特殊方法，可以让自定义对象通过加号<code>“+”</code>（或是别的运算符）进行运算。第<code>13</code>章对此有详细的介绍，现在只是借用这个例子来展示特殊方法的使用。</p>
<p>我们来实现一个二维向量（<code>vector</code>）类，这里的向量就是欧几里得几何中常用的概念，常在数学和物理中使用的那个（见图<code>1-1</code>）。</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201027160403.png"></p>
<p>上图是一个二维向量加法的例子，<code>Vector(2,4) + Vextor(2,1) = Vector(4,5)</code></p>
<p><code>Vector</code>二维向量类如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Vector(%r, %r)&#x27;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span>(<span class="params">self, scalar</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对这个类做向量的加法操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v1 = Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">v2 = Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">print(v1 + v2)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;Vector(<span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>注意其中的<strong>“<code>+</code>”</strong>运算符所得到的结果也是一个向量，而且结果能被控制台友好地打印出来。这个<strong>”<code>+</code>“</strong>操作符实际上是去调用<code>Vector</code>类里的<code>__add__</code>方法了。所以这也是<code>Python</code>强大的一个地方。</p>
<p><code>abs</code>是一个内置函数，如果输入是整数或者浮点数，它返回的是输入值的绝对值；如果输入是复数（<code>complex number</code>），那么返回这个复数的模。为了保持一致性，我们的<code>API</code>在碰到<code>abs</code>函数的时候，也应该返回该向量的模，<code>abs</code>函数会去调用<code>Vector</code>类的<code>__abs__()</code>方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v1 = Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(v1)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;<span class="number">5.0</span></span><br></pre></td></tr></table></figure>

<p>我们还可以利用<strong>”<code>*</code>“</strong>运算符来实现向量的标量乘法，该运算符实际上是去调用<code>Vector</code>类的<code>__mul__</code>方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">v1 = Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(v1 * <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;Vector(<span class="number">9</span>, <span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<p>虽然<code>Vector</code>类代码里有<code>6</code>个特殊方法，但这些方法（除了<code>__init__</code>）并不会在这个类自身的代码中使用。即便其他程序要使用这个类的这些方法，也不会直接调用它们，就像我们在上面的控制台对话中看到的。上文也提到过，一般只有<code>Python</code>的解释器会频繁地直接调用这些方法。接下来看看每个特殊方法的实现。</p>
<h4 id="字符串表示形式"><a href="#字符串表示形式" class="headerlink" title="字符串表示形式"></a>字符串表示形式</h4><p><code>Python</code>有一个内置的函数叫<code>repr</code>，它能把一个对象用字符串的形式表达出来以便辨认。<code>repr</code>函数命令就是通过<code>__repr__</code>这个特殊方法来得到一个对象的字符串表示形式的。如果没有实现<code>__repr__</code>，当我们在控制台里打印一个向量的实例时，得到的字符串可能会是 <code>&lt;Vector object at 0x10e100070&gt;</code>这种抽象表示。</p>
<p>在<code>__repr__</code>的实现中，我们用到了<code>%r</code>来获取对象各个属性的标准字符串表示形式——这是个好习惯。<code>__repr__ </code>所返回的字符串应该准确、无歧义，并且尽可能表达出如何用代码创建出这个被打印的对象。</p>
<p><code>__repr__ </code>和<code>__str__</code>的区别在于，后者是在<code>str()</code>函数被使用，或是在用<code>print</code>函数打印一个对象的时候才被调用的，并且它返回的字符串对终端用户更友好。如果你只想实现这两个特殊方法中的一个，<code>__repr__</code>是更好的选择，<font color=red>因为如果一个对象没有<code>__str__</code>函数，而<code>Python</code>又需要调用它的时候，解释器会用<code>__repr__</code>作为替代。</font></p>
<p>下面来看一个例子，<code>Vector</code>类在原来的基础上新增一个方法<code>__str__</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;i am __repr__ mathod, Vector(%r, %r)&#x27;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;i am __str__ mathod, Vector(%r, %r)&#x27;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    v1 = Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    print(<span class="string">&#x27;%s&#x27;</span> % v1) <span class="comment"># 注意前面是%s，代表着的意思是它会去执行Vector类里的__str__方法</span></span><br><span class="line">    print(<span class="string">&#x27;%r&#x27;</span> % v1) <span class="comment"># 注意前面是%r，代表着的意思是它会去执行Vector类里的__repr__方法</span></span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;i am __str__ mathod, Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">&gt;&gt;&gt;i am __repr__ mathod, Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>通过<code>__add__</code>和<code>__mul__</code>，示例为向量类带来了<strong>”<code>+</code>“</strong>和<strong>”<code>*</code>“</strong>这两个算术运算符。值得注意的是，这两个方法的返回值都是新创建的向量对象，被操作的两个向量还是原封不动，代码里只是读取了它们的值而已。<strong>中缀运算符</strong>的基本原则就是不改变操作对象，而是产出一个新的值。第 13 章会谈到更多这方面的问题。</p>
<h4 id="自定义的布尔值"><a href="#自定义的布尔值" class="headerlink" title="自定义的布尔值"></a>自定义的布尔值</h4><p>尽管<code>Python</code>里有<code>bool</code>类型，但实际上任何对象都可以用于需要布尔值的上下文中（比如<code>if</code>或<code>while</code>语句，或者<code>and</code>、<code>or</code>和<code>not</code>运算符）。为了判定一个值<code>x</code>为真还是为假，<code>Python</code>会调用<code>bool(x)</code>，这个函数只能返回<code>True</code>或者<code>False</code>。</p>
<p>默认情况下，我们自己定义的类的实例总被认为是真的，除非这个类对<code>__bool__</code>或者<code>__len__</code>函数有自己的实现。<code>bool(x) </code>的背后是调用<code>x.__bool__()</code>的结果；如果不存在<code>__bool__</code>方法，那么<code>bool(x)</code>会尝试调用<code>x.__len__()</code>。若返回<code>0</code>，则<code>bool</code>会返回<code>False</code>；否则返回<code>True</code>。</p>
<p>我们对<code>Vector</code>类中的<code>__bool__</code>的实现很简单，如果一个向量的模是<code>0</code>，那么就返回<code>False</code>，其他情况则返回<code>True</code>。因为<code>__bool__</code>函数的返回类型应该是布尔型，所以我们通过<code>bool(abs(self))</code>把模值变成了布尔值。</p>
<p>在<code>Python</code>标准库的文档中，有一节叫作“Built-in Types”（<a href="https://docs.python.org/3/library/stdtypes.html#truth">https://docs.python.org/3/library/stdtypes.html#truth</a>），其中规定了真值检验的标准。通过实现<code>__bool__</code>，你定义的对象就可以与这个标准保持一致。</p>
]]></content>
      <categories>
        <category>流畅的Python</category>
        <category>第一章 Python的数据模型</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python学习笔记-01数据模型-1-4</title>
    <url>/2020/10/28/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-1-4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>第一章第四节：为什么<code>len()</code>不是普通方法</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028144038.png"></p>
<a id="more"></a>

<h3 id="为什么len-不是普通方法"><a href="#为什么len-不是普通方法" class="headerlink" title="为什么len()不是普通方法"></a>为什么<code>len()</code>不是普通方法</h3><p>我在 2013 年问核心开发者 Raymond Hettinger 这个问题时，他用“<code>Python</code>之禅”（<a href="https://www.python.org/doc/humor/#the-zen-of-python">https://www.python.org/doc/humor/#the-zen-of-python</a>）里的原话回答了我：“实用胜于纯粹。”在 1.2 节里我提到过，如果 x 是一个<a href="https://docs.python.org/zh-cn/3/library/stdtypes.html">内置类型</a>的实例，那么 <code>len(x)</code> 的速度会非常快。背后的原因是 CPython 会直接从一个 C 结构体里读取对象的长度，完全不会调用任何方法。获取一个集合中元素的数量是一个很常见的操作，在<code>str</code>、<code>list</code>、<code>memoryview</code> 等类型上，这个操作必须高效。</p>
<!-- more -->

<p>换句话说，len 之所以不是一个普通方法，是为了让 Python 自带的数据结构可以走后门，abs 也是同理。但是多亏了它是特殊方法，我们也可以把 len 用于自定义数据类型。这种处理方式在保持内置类型的效率和保证语言的一致性之间找到了一个平衡点，也印证了“Python 之禅”中的另外一句话：“不能让特例特殊到开始破坏既定规则。”</p>
<p>如果把 abs 和 len 都看作一元运算符的话，你也许更能接受它们——虽然看起来像面向对象语言中的函数，但实际上又不是函数。有一门叫作 ABC 的语言是 Python 的直系祖先，它内置了一个# 运算符，当你写出 #s 的时候，它的作用跟 len 一样。如果写成x#s 这样的中缀运算符的话，那么它的作用是计算 s 中 x 出现的次数。在 Python 里对应的写法是 s.count(x)。注意这里的 s 是一个序列类型。</p>
]]></content>
      <categories>
        <category>流畅的Python</category>
        <category>第一章 Python的数据模型</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python学习笔记-01数据模型-1-3</title>
    <url>/2020/10/28/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-1-3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>第一章第三节：特殊方法一览</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028144038.png"></p>
<a id="more"></a>

<h3 id="特殊方法一览"><a href="#特殊方法一览" class="headerlink" title="特殊方法一览"></a>特殊方法一览</h3><p><code>Python</code>语言参考手册中的“<code>DataModel</code>”（<a href="https://docs.python.org/3/reference/datamodel.html">https://docs.python.org/3/reference/datamodel.html</a>）一章列出了83个特殊方法的名字，其中47个用于实现算术运算、位运算和比较操作。</p>
<p>跟运算符无关的特殊方法：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>方法名</th>
</tr>
</thead>
<tbody><tr>
<td>字符串、字节序列表示形式</td>
<td><code>__repr__</code>、<code>__str__</code>、<code>__format__</code>、<code>__bytes__</code></td>
</tr>
<tr>
<td>数值转换</td>
<td><code>__abs__</code>、<code>__bool__</code>、<code>__complex__</code>、<code>__int__</code>、<code>__float__</code>、<code>__hash__</code>、<code>__index__</code></td>
</tr>
<tr>
<td>集合模拟</td>
<td><code>__len__</code>、<code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code>、<code>__contains__</code></td>
</tr>
<tr>
<td>迭代枚举</td>
<td><code>__iter__</code>、<code>__reversed__</code>、<code>__next__</code></td>
</tr>
<tr>
<td>可调用模拟</td>
<td><code>__call__</code></td>
</tr>
<tr>
<td>上下文管理</td>
<td><code>__enter__</code>、<code>__exit__</code></td>
</tr>
<tr>
<td>实例创建和销毁</td>
<td><code>__new__</code>、<code>__init__</code>、<code>__del__</code></td>
</tr>
<tr>
<td>属性管理</td>
<td><code>__getattr__</code>、<code>__getattribute__</code>、<code>__setattr__</code>、<code>__delattr__</code>、<code>__dir__</code></td>
</tr>
<tr>
<td>属性描述符</td>
<td><code>__get__</code>、<code>__set__</code>、<code>__delete__</code></td>
</tr>
<tr>
<td>跟类相关的服务</td>
<td><code>__prepare__</code>、<code>__instancecheck__</code>、<code>__subclasscheck__</code></td>
</tr>
</tbody></table>
<!-- more -->

<p>跟运算符相关的特殊方法</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>方法名和对应的运算符</th>
</tr>
</thead>
<tbody><tr>
<td>一元运算符</td>
<td><code>__neg__</code>对应<code>-</code>、<code>__pos__</code>对应<code>+</code>、<code>__abs__</code>对应<code>abs()</code></td>
</tr>
<tr>
<td>众多比较运算符</td>
<td><code>__lt__</code>对应<code>&lt;</code>、<code>__le__</code>对应<code>&lt;=</code>、<code>__eq__</code>对应<code>==</code>、<code>__ne__</code>对应<code>!=</code>、<code>__gt__</code>对应<code>&gt;</code>、<code>__ge__</code>对应<code>&gt;=</code></td>
</tr>
<tr>
<td>算术运算符</td>
<td><code>__add__</code>对应<code>+</code>、<code>__sub__</code>对应<code>-</code>、<code>__mul__</code>对应<code>*</code>、<code>__truediv__</code>对应<code>/</code>、<code>__floordiv__</code>对应<code>//</code>、<code>__mod__</code>对应<code>%</code>、<code>__divmod__</code>对应<code>divmod()</code>、<code>__pow__</code>对应<code>**</code>或<code>pow()</code>、<code>__round__</code>对应<code>round()</code></td>
</tr>
<tr>
<td>反向算术运算符</td>
<td><code>__radd__</code>、<code>__rsub__</code>、<code>__rmul__</code>、<code>__rtruediv__</code>、<code>__rfloordiv__</code>、<code>__rmod__</code>、<code>__rdivmod__</code></td>
</tr>
<tr>
<td>增量赋值算术运算符</td>
<td><code>__iadd__</code>、<code>__isub__</code>、<code>__imul__</code>、<code>__itruediv__</code>、<code>__ifloordiv__</code>、<code>__imod__</code>、<code>__ipow__</code></td>
</tr>
<tr>
<td>位运算符</td>
<td><code>__invert__</code>对应<code>~</code>、<code>__lshift__</code>对应<code>&lt;&lt;</code>、<code>__rshift__</code>对应<code>&gt;&gt;</code>、<code>__and__</code>对应<code>&amp;</code>、<code>__or__</code>对应<code>^</code></td>
</tr>
<tr>
<td>反向位运算符</td>
<td><code>__rlshift__</code>、<code>__rrshift__</code>、<code>__rand__</code>、<code>__rxor__</code>、<code>__ror__</code></td>
</tr>
<tr>
<td>增量赋值位运算符</td>
<td><code>__ilshift__</code>、<code>__irshift__</code>、<code>__iand__</code>、<code>__ixor__</code>、<code>__ior__</code></td>
</tr>
</tbody></table>
<p>当交换两个操作数的位置时，就会调用反向运算符（<code>b * a</code>而不是<code>a * b</code>）。增量赋值运算符则是一种把中缀运算符变成赋值运算的捷径（<code>a = a * b</code>就变成了<code>a *= b</code>）。第13章会对这两者作出详细解释。</p>
]]></content>
      <categories>
        <category>流畅的Python</category>
        <category>第一章 Python的数据模型</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python学习笔记-02序列构成的数组-2-1</title>
    <url>/2020/10/29/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84-2-1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>第二章第一节：内置序列类型概览</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028144038.png"></p>
<a id="more"></a>

<h3 id="引读"><a href="#引读" class="headerlink" title="引读"></a>引读</h3><p>在创造 Python 以前，Guido 曾为 ABC 语言贡献过代码。ABC 语言是一个致力于为初学者设计编程环境的长达 10 年的研究项目，其中很多点子在现在看来都很有 Python 风格：序列的泛型操作、内置的元组和映射类型、用缩进来架构的源码、无需变量声明的强类型，等等。Python 对开发者如此友好，根源就在这里。</p>
<p>Python 也从 ABC 那里继承了用统一的风格去处理序列数据这一特点。不管是哪种数据结构，字符串、列表、字节序列、数组、XML元素，抑或是数据库查询结果，它们都共用一套丰富的操作：迭代、切片、排序，还有拼接。</p>
<p>深入理解 Python 中的不同序列类型，不但能让我们避免重新发明轮子，它们的 API 还能帮助我们把自己定义的 API 设计得跟原生的序列一样，或者是跟未来可能出现的序列类型保持兼容。</p>
<p>本章讨论的内容几乎可以应用到所有的序列类型上，从我们熟悉的list，到 Python 3 中特有的 str 和 bytes。我还会特别提到跟列表、元组、数组以及队列有关的话题。但是 Unicode 字符串和字节序列这方面的内容被放在了第 4 章。另外这里讨论的数据结构都是 Python中现成可用的，如果你想知道怎样创建自己的序列类型，那得等到第 10 章。</p>
<h3 id="内置序列类型概览"><a href="#内置序列类型概览" class="headerlink" title="内置序列类型概览"></a>内置序列类型概览</h3><p>Python 标准库用 C 实现了丰富的序列类型，列举如下。</p>
<ul>
<li><p>容器序列：</p>
<p><code>list</code>、<code>tuple</code> 和 <code>collections.deque</code> 这些序列能存放不同类型的数据。</p>
</li>
<li><p>扁平序列：</p>
<p><code>str</code>、<code>bytes</code>、<code>bytearray</code>、<code>memoryview</code> 和 <code>array.array</code>，这类序列只能容纳一种类型。</p>
</li>
</ul>
<p>容器序列存放的是它们所包含的任意类型的对象的引用，而扁平序列里存放的是值而不是引用。换句话说，<font color=red>扁平序列其实是一段连续的内存空间</font>。由此可见扁平序列其实更加紧凑，但是它里面只能存放诸如字符、字节和数值这种基础类型。</p>
<p>序列类型还能按照能否修改来分类。</p>
<ul>
<li><p>可变序列</p>
<p><code>list</code>、<code>bytearray</code>、<code>array.array</code>、<code>collections.deque</code> 和 <code>memoryview</code>。</p>
</li>
<li><p>不可变序列</p>
<p><code>tuple</code>、<code>str</code> 和 <code>bytes</code>。</p>
</li>
</ul>
<p>下图显示了可变序列（<code>MutableSequence</code>）和不可变序列（<code>Sequence</code>）的差异，同时也能看出前者从后者那里继承了一些方法。虽然内置的序列类型并不是直接从 <code>Sequence</code> 和 <code>MutableSequence</code> 这两个抽象基类（<code>Abstract Base Class</code>，ABC）继承而来的，但是了解这些基类可以帮助我们总结出那些完整的序列类型包含了哪些功能。</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201029133908.png"></p>
<p>上面那个 UML 类图列举了 <code>collections.abc</code> 中的几个类（超类在最上边，箭头从子类指向超类，斜体名称代表抽象类和抽象方法）通过记住这些类的共有特性，把可变与不可变序列或是容器与扁平序列的概念融会贯通，在探索并学习新的序列类型时，你会更加得心手。最重要也最基础的序列类型应该就是列表（list）了。list 是一个可变序列，并且能同时存放不同类型的元素。作为这本书的读者，我想你应该对它很了解了，因此让我们直接开始讨论列表推导（<code>listcomprehension</code>）吧。列表推导是一种构建列表的方法，它异常强大，然而由于相关的句法比较晦涩，人们往往不愿意去用它。掌握列表推导还可以为我们打开生成器表达式（<code>generator expression</code>）的大门，后者具有生成各种类型的元素并用它们来填充序列的功能。下一节就来看看这两个概念。</p>
]]></content>
      <categories>
        <category>流畅的Python</category>
        <category>第二章 序列构成的数组</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python学习笔记-02序列构成的数组-2-2</title>
    <url>/2020/10/29/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84-2-2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>第二章第一节：列表推导和生成器表达式</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028144038.png"></p>
<a id="more"></a>

<p>列表推导是构建列表（list）的快捷方式，而生成器表达式则可以用来创建其他任何类型的序列。如果你的代码里并不经常使用它们，那么很可能你错过了许多写出可读性更好且更高效的代码的机会。</p>
<p>如果你对我说的“更具可读性”持怀疑态度的话，别急着下结论，我马上就能说服你。</p>
<p>很多 Python 程序员都把列表推导（list comprehension）简称为 listcomps，生成式表达器（generator expression）则称为genexps。我有时也会这么用。</p>
<h3 id="列表推导和可读性"><a href="#列表推导和可读性" class="headerlink" title="列表推导和可读性"></a>列表推导和可读性</h3><p>先来个小测试，你觉得示例 2-1 和示例 2-2 中的代码，哪个更容易读懂？</p>
<p>示例 2-1 把一个字符串变成 Unicode 码位的列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">symbols = <span class="string">&#x27;$¢£¥€¤&#x27;</span></span><br><span class="line">codes = []</span><br><span class="line"><span class="keyword">for</span> symbol <span class="keyword">in</span> symbols:</span><br><span class="line">  codes.append(ord(symbol))</span><br><span class="line">print(codes)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;[<span class="number">36</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>]</span><br></pre></td></tr></table></figure>

<p>示例 2-2 把字符串变成 Unicode 码位的另外一种写法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">symbols = <span class="string">&#x27;$¢£¥€¤&#x27;</span></span><br><span class="line">codes = [ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols]</span><br><span class="line">print(codes)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;[<span class="number">36</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>]</span><br></pre></td></tr></table></figure>

<p>虽说任何学过一点 Python 的人应该都能看懂示例 2-1，但是我觉得如果学会了列表推导的话，示例 2-2 读起来更方便，因为这段代码的功能从字面上就能轻松地看出来。</p>
<p>for 循环可以胜任很多任务：遍历一个序列以求得总数或挑出某个特定的元素、用来计算总和或是平均数，还有其他任何你想做的事情。在示例 2-1 的代码里，它被用来新建一个列表。</p>
<p>另一方面，列表推导也可能被滥用。<font color=red>通常的原则是，只用列表推导来创建新的列表，并且尽量保持简短</font>。如果列表推导的代码超过了两行，你可能就要考虑是不是得用 for 循环重写了。就跟写文章一样，并没有什么硬性的规则，这个度得你自己把握。</p>
<p>Python 会忽略代码里 []、{} 和 () 中的换行，因此如果你的代码里有多行的列表、列表推导、生成器表达式、字典这一类的，可以省略不太好看的续行符 <code>\</code>。</p>
<p>列表推导不会再有变量泄漏的问题。</p>
<p>Python 2.x 中，在列表推导中 for 关键词之后的赋值操作可能会影响列表推导上下文中的同名变量。像下面这个 Python 2.7 控制台对话：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Python <span class="number">2.7</span><span class="number">.6</span> (default, Mar <span class="number">22</span> <span class="number">2014</span>, <span class="number">22</span>:<span class="number">59</span>:<span class="number">38</span>)</span><br><span class="line">[GCC <span class="number">4.8</span><span class="number">.2</span>] on linux2</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;my precious&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dummy = [x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="string">&#x27;C</span></span><br></pre></td></tr></table></figure>

<p>如你所见，x 原本的值被取代了，但是这种情况在 Python 3 中是不会出现的。</p>
<p>列表推导、生成器表达式，以及同它们很相似的集合（set）推导和字典（dict）推导，在 Python 3 中都有了自己的局部作用域，就像函数似的。表达式内部的变量和赋值只在局部起作用，表达式的上下文里的同名变量还可以被正常引用，局部变量并不会影响到它们。</p>
<p>这是Python 3 代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="string">&#x27;ABC&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dummy = [ord(x) <span class="keyword">for</span> x <span class="keyword">in</span> x]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x ➊</span><br><span class="line"><span class="string">&#x27;ABC&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dummy ➋</span><br><span class="line">[<span class="number">65</span>, <span class="number">66</span>, <span class="number">67</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>➊ x 的值被保留了。</p>
<p>➋ 列表推导也创建了正确的列表。</p>
<p>列表推导可以帮助我们把一个序列或是其他可迭代类型中的元素过滤或是加工，然后再新建一个列表。Python 内置的 <code>filter</code> 和 <code>map</code> 函数组合起来也能达到这一效果，但是可读性上打了不小的折扣。</p>
<h3 id="列表推导同filter和map的比较"><a href="#列表推导同filter和map的比较" class="headerlink" title="列表推导同filter和map的比较"></a>列表推导同filter和map的比较</h3><p>filter 和 map 合起来能做的事情，列表推导也可以做，而且还不需要借助难以理解和阅读的 lambda 表达式。详见示例 2-3。</p>
<p>示例 2-3 用列表推导和 map/filter 组合来创建同样的表单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>symbols = <span class="string">&#x27;$¢£¥€¤&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>beyond_ascii = [ord(s) <span class="keyword">for</span> s <span class="keyword">in</span> symbols <span class="keyword">if</span> ord(s) &gt; <span class="number">127</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>beyond_ascii</span><br><span class="line">[<span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>beyond_ascii = list(filter(<span class="keyword">lambda</span> c: c &gt; <span class="number">127</span>, map(ord, symbols)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>beyond_ascii</span><br><span class="line">[<span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>]</span><br></pre></td></tr></table></figure>

<p>我原以为 map/filter 组合起来用要比列表推导快一些，Alex Martelli却说不一定——至少在上面这个例子中不一定。在本书的代码仓库（<a href="https://github.com/fluentpython/example-code">https://github.com/fluentpython/example-code</a>）中有名为02-array-seq/listcomp_speed.py（<a href="https://github.com/fluentpython/example-code/blob/master/02-array-seq/listcomp_speed.py">https://github.com/fluentpython/example-code/blob/master/02-array-seq/listcomp_speed.py</a>）的脚本，代码中有这两个方法的效率的比较。</p>
<p>第 5 章会更详细地讨论 map 和 filter。下面就来看看如何用列表推导来计算笛卡儿积：两个或以上的列表中的元素对构成元组，这些元组构成的列表就是笛卡儿积。</p>
<h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><p>如前所述，用列表推导可以生成两个或以上的可迭代类型的笛卡儿积。笛卡儿积是一个列表，列表里的元素是由输入的可迭代类型的元素对构成的元组，因此笛卡儿积列表的长度等于输入变量的长度的乘积，如下图所示：</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201029144759.png"></p>
<p>上图含有 4 种花色和 3 种牌面的列表的笛卡儿积，结果是一个包含 12 个元素的列表。</p>
<p>如果你需要一个列表，列表里是 3 种不同尺寸的 T 恤衫，每个尺寸都有2 个颜色，示例 2-4 用列表推导算出了这个列表，列表里有 6 种组合。</p>
<p>示例 2-4 使用列表推导计算笛卡儿积：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sizes = [<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;L&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tshirts = [(color, size) <span class="keyword">for</span> color <span class="keyword">in</span> colors <span class="keyword">for</span> size <span class="keyword">in</span> sizes] ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tshirts</span><br><span class="line">[(<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;S&#x27;</span>), (<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;L&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;S&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;L&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> color <span class="keyword">in</span> colors: ➋</span><br><span class="line"><span class="meta">... </span><span class="keyword">for</span> size <span class="keyword">in</span> sizes:</span><br><span class="line"><span class="meta">... </span>print((color, size))</span><br><span class="line">...</span><br><span class="line">(<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;M&#x27;</span>)</span><br><span class="line">(<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;L&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tshirts = [(color, size) <span class="keyword">for</span> size <span class="keyword">in</span> sizes ➌</span><br><span class="line"><span class="meta">... </span><span class="keyword">for</span> color <span class="keyword">in</span> colors]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tshirts</span><br><span class="line">[(<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;S&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;S&#x27;</span>), (<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;M&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;M&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;L&#x27;</span>), (<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;L&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<p>➊ 这里得到的结果是先以颜色排列，再以尺码排列。</p>
<p>➋ 注意，这里两个循环的嵌套关系和上面列表推导中 for 从句的先后顺序一样。</p>
<p>➌ 如果想依照先尺码后颜色的顺序来排列，只需要调整从句的顺序。我在这里插入了一个换行符，这样顺序安排就更明显了。</p>
<p><font color=red><strong>列表推导的作用只有一个：生成列表（list）。如果想生成其他类型的序列，生成器表达式就派上了用场。下一节就是对生成器表达式的一个简单介绍，其中可以看到如何用它生成列表以外的序列类型。</strong></font></p>
<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><p>虽然也可以用列表推导来初始化元组、数组或其他序列类型，但是生成器表达式是更好的选择。<strong>这是因为生成器表达式背后遵守了迭代器协议，可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里</strong>。前面那种方式显然能够节省内存。</p>
<p>生成器表达式的语法跟列表推导差不多，只不过把方括号换成圆括号而已。</p>
<p>示例 2-5 用生成器表达式初始化元组和数组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>symbols = <span class="string">&#x27;$¢£¥€¤&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tuple(ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols) ➊</span><br><span class="line">(<span class="number">36</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> array</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>array.array(<span class="string">&#x27;I&#x27;</span>, (ord(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols)) ➋</span><br><span class="line">array(<span class="string">&#x27;I&#x27;</span>, [<span class="number">36</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>])</span><br></pre></td></tr></table></figure>

<p>➊ 如果生成器表达式是一个函数调用过程中的唯一参数，那么不需要额外再用括号把它围起来。</p>
<p>➋ array 的构造方法需要两个参数，因此括号是必需的。array 构造方法的第一个参数指定了数组中数字的存储方式。2.9.1 节中有更多关于数组的详细讨论。</p>
<p>示例 2-6 则是利用生成器表达式实现了一个笛卡儿积，用以打印出上文中我们提到过的 T 恤衫的 2 种颜色和 3 种尺码的所有组合。与示例 2-4不同的是，用到生成器表达式之后，内存里不会留下一个有 6 个组合的列表，因为生成器表达式会在每次 for 循环运行时才生成一个组合。如果要计算两个各有 1000 个元素的列表的笛卡儿积，生成器表达式就可以帮忙省掉运行 for 循环的开销，即一个含有 100 万个元素的列表。</p>
<p>示例 2-6 使用生成器表达式计算笛卡儿积：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sizes = [<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;L&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> tshirt <span class="keyword">in</span> (<span class="string">&#x27;%s %s&#x27;</span> % (c, s) <span class="keyword">for</span> c <span class="keyword">in</span> colors <span class="keyword">for</span> s <span class="keyword">in</span> sizes): ➊</span><br><span class="line"><span class="meta">... </span>print(tshirt)</span><br><span class="line">...</span><br><span class="line">black S</span><br><span class="line">black M</span><br><span class="line">black L</span><br><span class="line">white S</span><br><span class="line">white M</span><br><span class="line">white L</span><br></pre></td></tr></table></figure>

<p>➊ 生成器表达式逐个产出元素，从来不会一次性产出一个含有 6 个 T恤样式的列表。</p>
<p>第 14 章会专门讲到生成器的工作原理。这里只是简单看看如何用生成器来初始化除列表之外的序列，以及如何用它来避免额外的内存占用。</p>
<h3 id="如何理解可迭代对象、迭代器和生成器"><a href="#如何理解可迭代对象、迭代器和生成器" class="headerlink" title="如何理解可迭代对象、迭代器和生成器"></a>如何理解可迭代对象、迭代器和生成器</h3><p>在讨论可迭代对象、迭代器和生成器之前，先说明一下<strong>迭代器模式（iterator pattern）</strong>，维基百科这么解释：</p>
<blockquote>
<p>迭代器是一种最简单也最常见的设计模式。它可以让用户透过特定的接口巡访容器中的每一个元素而不用了解底层的实现。</p>
</blockquote>
<p>迭代是数据处理的基石。当内存中放不下数据集时，我们要找到一种<strong>惰性</strong>获取数据的方式，即按需一次获取一个数据项，这就是迭代器模式。</p>
<p>我们都知道序列是可迭代的。当解释器需要迭代对象x时，会自动调用iter(x)函数时。内置的iter函数有以下作用：</p>
<ul>
<li>检查对象是否实现了<code>__iter__</code>方法，如果实现了就调用它，获得一个迭代器。</li>
<li>如果没有实现<code>__iter__</code>方法，但是实现了<code>__getitem__</code>方法，python会创建一个迭代器，尝试按顺序（从索引0开始）获取元素。</li>
<li>如果尝试失败，python会抛出<code>TypeError</code>异常，通常会提示”C object is not iterable”，其中C是目标对象所属的类。</li>
</ul>
<p>截止到Python3.6，基本上所有的Python序列也都实现了<code>__getitem__</code>方法，这是保证任何序列都可迭代的原因。当然标准的序列也都实现了<code>__iter__</code>方法，之所以对<code>__getitem__</code>也可以创建迭代器是为了向后兼容，未来可能不在这么做。</p>
<p>但是，从Python3.4开始，检查x能否迭代，最准确的方法是调用iter(x)函数，如果不可迭代，再处理TypeError异常。</p>
<p><strong>使用iter内置函数可以获取<font color=red>迭代器对象</font>。</strong>也就是说，如果一个对象实现了能返回迭代器的<code>__iter__</code>方法，那么对象就是可迭代的，序列都可以迭代；实现了<code>__getitem__</code>方法，而且其参数是从零开始的索引，这种对象也是可迭代的。</p>
<p>因此可以明确<strong>可迭代对象</strong>和<strong>迭代器</strong>之间的关系：<strong>Python从可迭代的对象中获取迭代器。</strong></p>
<p>标准的迭代器接口有两个方法，即：</p>
<ul>
<li><p><code>__next__</code>：返回下一个可用元素，如果没有元素，抛出StopIteration异常。</p>
</li>
<li><p><code>__iter__</code>：返回self，以便在应该使用可迭代对象的地方使用迭代器，比如for循环中。</p>
</li>
</ul>
<p>因为迭代器只需<code>__next__</code>和<code>__iter__</code>两个方法，所以除了调用next()方法，以及捕获StopIteration异常之外，没有办法检查是否还有遗留的元素。此外，也没有办法还原迭代器。如果想再次迭代，那就要调用iter(…)，传入之前构建迭代器的可迭代对象。</p>
<p>构建<code>可迭代对象</code>和<code>迭代器</code>时经常会出现错误，原因是混淆了两者。要知道，<code>可迭代的对象</code>有个<code>__iter__</code>方法，<strong>调用该方法每次都实例化一个新的迭代器</strong>；而<code>迭代器</code>要实现<code>__next__</code>方法，返回单个元素，此外还要实现<code>__iter__</code>方法，返回迭代器本身(self)，如图。因此，<code>迭代器</code>可以迭代，但是<code>可迭代的对象</code>不是<code>迭代器</code>。</p>
<p><u><strong>需要注意的是：</strong></u></p>
<p>可迭代的对象必须实现<code>__iter__</code>方法，但<strong>不能</strong>实现<code>__next__</code>方法。另一方面，迭代器应该一直可以迭代，迭代器的<code>__iter__</code>方法应该返回自身。虽然可迭代对象和迭代器都有<code>__iter__</code>方法，但是两者的功能不一样，再次强调一下，可迭代对象的<code>__iter__</code>用于实例化一个迭代器对象，而迭代器中的<code>__iter__</code>用于返回迭代器本身，与<code>__next__</code>共同完成迭代器的迭代作用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFib</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pre = <span class="number">0</span></span><br><span class="line">        self.curr = <span class="number">1</span></span><br><span class="line">        self.lists = [ii <span class="keyword">for</span> ii <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.lists[item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fib = MyFib()</span><br><span class="line">    fic = iter(fib)<span class="comment">#MyFib类实现了__getitem__方法，调用内置函数iter，python会为fib创建一个迭代器对象，并返回之。因为fic是迭代器对象，才可通过for循环迭代。</span></span><br><span class="line">    <span class="comment"># for i in fib: #此行会报错</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> fic:</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure>

<p>迭代器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFib</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pre = <span class="number">0</span></span><br><span class="line">        self.curr = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.curr, self.pre = self.curr + self.pre, self.curr</span><br><span class="line">        <span class="keyword">return</span> self.curr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fib = MyFib()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(next(fib))</span><br></pre></td></tr></table></figure>

<p><strong>生成器和yield</strong></p>
<p>生成器其实是一种特殊的迭代器，但是不需要像迭代器一样实现<code>__iter__</code>和<code>__next__</code>方法，只需要使用关键字yield就可以。</p>
<p>我们来实现一个同样的斐波那契数列，但这次使用的是生成器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>():</span></span><br><span class="line">    prev, curr = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> curr</span><br><span class="line">        curr, prev = prev + curr, curr</span><br><span class="line"></span><br><span class="line">f = fib()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    print(next(f))</span><br></pre></td></tr></table></figure>

<p>输出打印：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>上面的 fib 函数中没有 return 关键字。当运行 f = fib() 的时候，它返回的是一个生成器对象。在调用 fib() 的时候并不会运行 fib 函数中的代码，只有在调用 next() 的时候才会真正运行其中的代码。使用生成器，函数不用一次性生成所有的元素，只需在每次调用next的时候生成元素，这样更节省内存和CPU。</p>
<p>再看一个生成器函数的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_123</span>():</span>  <span class="comment"># 只要Python代码中包含yield，该函数就是生成器函数</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>    <span class="comment">#生成器函数的定义体中通常都有循环，不过这不是必要条件；此处重复使用了3次yield</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    print(gen_123)    <span class="comment"># 可以看出gen_123是函数对象</span></span><br><span class="line">    <span class="comment"># &lt;function gen_123 at 0x10be19&gt;</span></span><br><span class="line">    print(gen_123())  <span class="comment"># 函数调用时返回的是一个生成器对象</span></span><br><span class="line">    <span class="comment"># &lt;generator object gen_123 at 0x10be31&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> gen_123(): <span class="comment"># 生成器是迭代器，会生成传给yield关键字的表达式的值</span></span><br><span class="line">        print(i)    </span><br><span class="line">        <span class="comment"># 1</span></span><br><span class="line">        <span class="comment"># 2</span></span><br><span class="line">        <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">    g = gen_123() <span class="comment"># 为了仔细检查，把生成器对象赋值给g</span></span><br><span class="line">    print(next(g))  <span class="comment"># 1</span></span><br><span class="line">    print(next(g))  <span class="comment"># 2</span></span><br><span class="line">    print(next(g))  <span class="comment"># 3</span></span><br><span class="line">    print(next(g))   <span class="comment"># 生成器函数的定义体执行完毕后，生成器对象会抛出异常。</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;test.py&quot;, line 17, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     print(next(g))</span></span><br><span class="line"><span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>流畅的Python</category>
        <category>第二章 序列构成的数组</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python学习笔记-02序列构成的数组-2-3</title>
    <url>/2020/10/29/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84-2-3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>第二章第三节：元组不仅仅是不可变的列表</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028144038.png"></p>
<a id="more"></a>

<p>有些 Python 入门教程把元组称为“不可变列表”，然而这并没有完全概括元组的特点。除了用作不可变的列表，它还可以用于没有字段名的记录。鉴于后者常常被忽略，我们先来看看元组作为记录的功能。</p>
<h3 id="元组和记录"><a href="#元组和记录" class="headerlink" title="元组和记录"></a>元组和记录</h3><p>元组其实是对数据的记录：元组中的每个元素都存放了记录中一个字段的数据，外加这个字段的位置。正是这个位置信息给数据赋予了意义。</p>
<p>如果只把元组理解为不可变的列表，那其他信息——它所含有的元素的总数和它们的位置——似乎就变得可有可无。但是如果把元组当作一些字段的集合，那么数量和位置信息就变得非常重要了。</p>
<p>示例 2-7 中的元组就被当作记录。如果在任何的表达式里我们在元组内对元素排序，这些元素所携带的信息就会丢失，因为这些信息是跟它们的位置有关的。</p>
<p>示例 2-7 把元组用作记录：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lax_coordinates = (<span class="number">33.9425</span>, <span class="number">-118.408056</span>) ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>city, year, pop, chg, area = (<span class="string">&#x27;Tokyo&#x27;</span>, <span class="number">2003</span>, <span class="number">32450</span>, <span class="number">0.66</span>, <span class="number">8014</span>) ➋</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>traveler_ids = [(<span class="string">&#x27;USA&#x27;</span>, <span class="string">&#x27;31195855&#x27;</span>), (<span class="string">&#x27;BRA&#x27;</span>, <span class="string">&#x27;CE342567&#x27;</span>), ➌</span><br><span class="line"><span class="meta">... </span>(<span class="string">&#x27;ESP&#x27;</span>, <span class="string">&#x27;XDA205856&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> passport <span class="keyword">in</span> sorted(traveler_ids): ➍</span><br><span class="line"><span class="meta">... </span>print(<span class="string">&#x27;%s/%s&#x27;</span> % passport) ➎</span><br><span class="line">...</span><br><span class="line">BRA/CE342567</span><br><span class="line">ESP/XDA205856</span><br><span class="line">USA/<span class="number">31195855</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> country, _ <span class="keyword">in</span> traveler_ids: ➏</span><br><span class="line"><span class="meta">... </span>print(country)</span><br><span class="line">...</span><br><span class="line">USA</span><br><span class="line">BRA</span><br><span class="line">ESP</span><br></pre></td></tr></table></figure>

<p>❶ 洛杉矶国际机场的经纬度。</p>
<p>❷ 东京市的一些信息：市名、年份、人口（单位：百万）、人口变化（单位：百分比）和面积（单位：平方千米）。</p>
<p>❸ 一个元组列表，元组的形式为 (country_code, passport_number)。</p>
<p>❹ 在迭代的过程中，passport 变量被绑定到每个元组上。</p>
<p>❺ % 格式运算符能被匹配到对应的元组元素上。</p>
<p>❻ for 循环可以分别提取元组里的元素，也叫作拆包（unpacking）。因为元组中第二个元素对我们没有什么用，所以它赋值给“_”占位符。</p>
<p>拆包让元组可以完美地被当作记录来使用，这也是下一节的话题。</p>
<h3 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h3><p>示例 2-7 中，我们把元组 (‘Tokyo’, 2003, 32450, 0.66, 8014) 里的元素分别赋值给变量 city、year、pop、chg 和 area，而这所有的赋值我们只用一行声明就写完了。同样，在后面一行中，一个 % 运算符就把 passport 元组里的元素对应到了 print 函数的格式字符串空档中。这两个都是对元组拆包的应用。</p>
<p><strong>元组拆包可以应用到任何可迭代对象上</strong>，唯一的硬性要求是，被可迭代对象中的元素数量必须要跟接受这些元素的元组的空档数一致。除非我们用 <code>*</code> 来表示忽略多余的元素，在用 <code>*</code> 来处理多余的元素一节里，我会讲到它的具体用法。Python 爱好者们很喜欢用元组拆包这个说法，但是可迭代元素拆包这个表达也慢慢流行了起来，比如“PEP 3132—Extended IterableUnpacking”（<a href="https://www.python.org/dev/peps/pep-3132/">https://www.python.org/dev/peps/pep-3132/</a>）的标题就是这么用的。</p>
<p>上面提到<font color=red><strong>元组拆包可以应用到任何可迭代对象上</strong></font>，这句话要怎么理解呢？看下面一段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFib</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.pre = <span class="number">0</span></span><br><span class="line">        self.curr = <span class="number">1</span></span><br><span class="line">        self.lists = [ii <span class="keyword">for</span> ii <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, item</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.lists[item]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    fib = MyFib()</span><br><span class="line">    fic = iter(fib)<span class="comment"># 因为类有__getitem__方法，即使它没有__iter__方法，也可以经过iter内置函数获得MyFib的迭代器对象</span></span><br><span class="line">    a, *b, c = fic<span class="comment"># 科迭代对象经过拆包，把其内部属性lists分别拆包赋值给a、b、c变量</span></span><br><span class="line">    print(a)</span><br><span class="line">    print(b)</span><br><span class="line">    print(c)</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;<span class="number">0</span></span><br><span class="line">&gt;&gt;&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">&gt;&gt;&gt;<span class="number">9</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 Python 开发中经常可以看到变量交换的代码，非常优雅，不使用中间变量交换两个变量的值，如下的方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b, a = a, b</span><br></pre></td></tr></table></figure>

<p>其实 <code>=</code> 号右边就是一个元组，然后拆包赋值给 b 和 a 两个变量。怎么看 <code>=</code> 号右边是一个元组呢？通过下面代码来论证：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="number">10</span></span><br><span class="line">    c = a, b</span><br><span class="line">    print(c)</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;(<span class="number">5</span>, <span class="number">10</span>)<span class="comment"># 变量c打印出来就是一个元组    </span></span><br></pre></td></tr></table></figure>

<p>可以用 <code>*</code> 运算符把一个可迭代对象拆开作为函数的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>divmod(<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">20</span>, <span class="number">8</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>divmod(*t)</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quotient, remainder = divmod(*t)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quotient, remainder</span><br><span class="line">(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>下面是另一个例子，这里元组拆包的用法则是让一个函数可以用元组的形式返回多个值，然后调用函数的代码就能轻松地接受这些返回值。比如 os.path.split() 函数就会返回以路径和最后一个文件名组成的元组 (path, last_part):</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    path, filename = os.path.split(<span class="string">&#x27;/home/luciano/.ssh/idrsa.pub&#x27;</span>)</span><br><span class="line">    print(path)</span><br><span class="line">    print(filename)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;/home/luciano/.ssh</span><br><span class="line">&gt;&gt;&gt;idrsa.pub</span><br></pre></td></tr></table></figure>

<p>在进行拆包的时候，我们不总是对元组里所有的数据都感兴趣，<code>_</code> 占位符能帮助处理这种情况，上面这段代码也展示了它的用法。</p>
<p>除此之外，在元组拆包中使用 <code>*</code> 也可以帮助我们把注意力集中在元组的部分元素上。</p>
<p>用 <code>*</code> 来处理剩下的元素。</p>
<p>在 Python 中，函数用 <code>*args</code> 来获取不确定数量的参数算是一种经典写法了。</p>
<p>于是 Python 3 里，这个概念被扩展到了平行赋值中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = range(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = range(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, *rest = range(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b, rest</span><br><span class="line">(<span class="number">0</span>, <span class="number">1</span>, [])</span><br></pre></td></tr></table></figure>

<p>在平行赋值中，<code>*</code> 前缀只能用在一个变量名前面，但是这个变量可以出现在赋值表达式的任意位置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, *body, c, d = range(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, body, c, d</span><br><span class="line">(<span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>*head, b, c, d = range(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>head, b, c, d</span><br><span class="line">([<span class="number">0</span>, <span class="number">1</span>], <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>另外元组拆包还有个强大的功能，那就是可以应用在嵌套结构中。</p>
<h3 id="嵌套元组拆包"><a href="#嵌套元组拆包" class="headerlink" title="嵌套元组拆包"></a>嵌套元组拆包</h3><p>接受表达式的元组可以是嵌套式的，例如 (a, b, (c, d))。只要这个接受元组的嵌套结构符合表达式本身的嵌套结构，Python 就可以作出正确的对应。示例 2-8 就是对嵌套元组拆包的应用。</p>
<p>示例 2-8 用嵌套元组来获取经度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">metro_areas = [</span><br><span class="line">(<span class="string">&#x27;Tokyo&#x27;</span>,<span class="string">&#x27;JP&#x27;</span>,<span class="number">36.933</span>,(<span class="number">35.689722</span>,<span class="number">139.691667</span>)), <span class="comment"># ➊</span></span><br><span class="line">(<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, (<span class="number">28.613889</span>, <span class="number">77.208889</span>)),</span><br><span class="line">(<span class="string">&#x27;Mexico City&#x27;</span>, <span class="string">&#x27;MX&#x27;</span>, <span class="number">20.142</span>, (<span class="number">19.433333</span>, <span class="number">-99.133333</span>)),</span><br><span class="line">(<span class="string">&#x27;New York-Newark&#x27;</span>, <span class="string">&#x27;US&#x27;</span>, <span class="number">20.104</span>, (<span class="number">40.808611</span>, <span class="number">-74.020386</span>)),</span><br><span class="line">(<span class="string">&#x27;Sao Paulo&#x27;</span>, <span class="string">&#x27;BR&#x27;</span>, <span class="number">19.649</span>, (<span class="number">-23.547778</span>, <span class="number">-46.635833</span>)),</span><br><span class="line">]</span><br><span class="line">print(<span class="string">&#x27;&#123;:15&#125; | &#123;:^9&#125; | &#123;:^9&#125;&#x27;</span>.format(<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;lat.&#x27;</span>, <span class="string">&#x27;long.&#x27;</span>)) <span class="comment"># &quot;^9&quot; 代表占9个空格，内容居中对齐</span></span><br><span class="line">fmt = <span class="string">&#x27;&#123;:15&#125; | &#123;:9.4f&#125; | &#123;:9.4f&#125;&#x27;</span><span class="comment"># &#123;:15&#125;意思是占位15个空格，&#123;:9.4f&#125; 意思是占位9位空格，4位小数部分</span></span><br><span class="line"><span class="keyword">for</span> name, cc, pop, (latitude, longitude) <span class="keyword">in</span> metro_areas: <span class="comment"># ➋</span></span><br><span class="line"><span class="keyword">if</span> longitude &lt;= <span class="number">0</span>: <span class="comment"># ➌</span></span><br><span class="line">print(fmt.format(name, latitude, longitude))</span><br></pre></td></tr></table></figure>

<p>❶ 每个元组内有 4 个元素，其中最后一个元素是一对坐标。</p>
<p>❷ 我们把输入元组的最后一个元素拆包到由变量构成的元组里，这样<br>就获取了坐标。</p>
<p>❸ <code>if longitude &lt;= 0:</code> 这个条件判断把输出限制在西半球的城市。</p>
<p>示例 2-8 的输出是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">               |       lat. | long.</span><br><span class="line">Mexico City    |    <span class="number">19.4333</span> | <span class="number">-99.1333</span></span><br><span class="line">New York-Newark|    <span class="number">40.8086</span> | <span class="number">-74.0204</span></span><br><span class="line">Sao Paul       |   <span class="number">-23.5478</span> | <span class="number">-46.63</span></span><br></pre></td></tr></table></figure>

<p>在 Python 3 之前，元组可以作为形参放在函数声明中，例如def fn(a, (b, c), d):。然而 Python 3 不再支持这种格式，具体原因见于“PEP 3113—Removal of Tuple ParameterUnpacking”（<a href="http://python.org/dev/peps/pep-3113/">http://python.org/dev/peps/pep-3113/</a>）。需要弄清楚的是，这个改变对函数调用者并没有影响，它改变的是某些函数的声明方式。</p>
<p>元组已经设计得很好用了，但作为记录来用的话，还是少了一个功能：我们时常会需要给记录中的字段命名。namedtuple 函数的出现帮我们解决了这个问题。</p>
<h3 id="具名元组"><a href="#具名元组" class="headerlink" title="具名元组"></a>具名元组</h3><p>collections.namedtuple 是一个工厂函数，它可以用来构建一个带字段名的元组和一个有名字的类——这个带名字的类对调试程序有很大帮助。</p>
<p>用 namedtuple 构建的类的实例所消耗的内存跟元组是一样的，因为字段名都被存在对应的类里面。这个实例跟普通的对象实例比起来也要小一些，因为 Python 不会用 <code>__dict__</code> 来存放这些实例的属性。</p>
<p>在第 1 章中，展示过这样一段代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Card = collections.namedtuple(<span class="string">&#x27;Card&#x27;</span>, [<span class="string">&#x27;rank&#x27;</span>, <span class="string">&#x27;suit&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>示例 2-9 展示了如何用具名元组来记录一个城市的信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>City = namedtuple(<span class="string">&#x27;City&#x27;</span>, <span class="string">&#x27;name country population coordinates&#x27;</span>) ➊</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo = City(<span class="string">&#x27;Tokyo&#x27;</span>, <span class="string">&#x27;JP&#x27;</span>, <span class="number">36.933</span>, (<span class="number">35.689722</span>, <span class="number">139.691667</span>)) ➋</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo</span><br><span class="line">City(name=<span class="string">&#x27;Tokyo&#x27;</span>, country=<span class="string">&#x27;JP&#x27;</span>, population=<span class="number">36.933</span>, coordinates=(<span class="number">35.689722</span>,</span><br><span class="line"><span class="number">139.691667</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo.population ➌</span><br><span class="line"><span class="number">36.933</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo.coordinates</span><br><span class="line">(<span class="number">35.689722</span>, <span class="number">139.691667</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo[<span class="number">1</span>]</span><br><span class="line"><span class="string">&#x27;JP</span></span><br></pre></td></tr></table></figure>

<p>❶ 创建一个具名元组需要两个参数，一个是类名，另一个是类的各个字段的名字。后者可以是由数个字符串组成的可迭代对象，或者是由空格分隔开的字段名组成的字符串。</p>
<p>❷ 存放在对应字段里的数据要以一串参数的形式传入到构造函数中（注意，元组的构造函数却只接受单一的可迭代对象）。</p>
<p>❸ 你可以通过字段名或者位置来获取一个字段的信息。</p>
<p>除了从普通元组那里继承来的属性之外，具名元组还有一些自己专有的属性。示例 2-10 中就展示了几个最有用的：_fields 类属性、类方法_make(iterable) 和实例方法 _asdict()。</p>
<p>示例 2-10 具名元组的属性和方法（接续前一个示例）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>City._fields ➊</span><br><span class="line">(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;country&#x27;</span>, <span class="string">&#x27;population&#x27;</span>, <span class="string">&#x27;coordinates&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>LatLong = namedtuple(<span class="string">&#x27;LatLong&#x27;</span>, <span class="string">&#x27;lat long&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>delhi_data = (<span class="string">&#x27;Delhi NCR&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>, <span class="number">21.935</span>, LatLong(<span class="number">28.613889</span>, <span class="number">77.208889</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>delhi = City._make(delhi_data) ➋</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>delhi._asdict() ➌</span><br><span class="line">OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Delhi NCR&#x27;</span>), (<span class="string">&#x27;country&#x27;</span>, <span class="string">&#x27;IN&#x27;</span>), (<span class="string">&#x27;population&#x27;</span>,</span><br><span class="line"><span class="number">21.935</span>), (<span class="string">&#x27;coordinates&#x27;</span>, LatLong(lat=<span class="number">28.613889</span>, long=<span class="number">77.208889</span>))])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> key, value <span class="keyword">in</span> delhi._asdict().items():</span><br><span class="line">print(key + <span class="string">&#x27;:&#x27;</span>, value)</span><br><span class="line">name: Delhi NCR</span><br><span class="line">country: IN</span><br><span class="line">population: <span class="number">21.935</span></span><br><span class="line">coordinates: LatLong(lat=<span class="number">28.613889</span>, long=<span class="number">77.208889</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>❶ _fields 属性是一个包含这个类所有字段名称的元组。</p>
<p>❷ 用 _make() 通过接受一个可迭代对象来生成这个类的一个实例，它的作用跟 City(*delhi_data) 是一样的。</p>
<p>❸ _asdict() 把具名元组以 collections.OrderedDict 的形式返回，我们可以利用它来把元组里的信息友好地呈现出来。</p>
<p>现在我们知道了，元组是一种很强大的可以当作记录来用的数据类型。它的第二个角色则是充当一个不可变的列表。下面就来看看它的第二重功能。</p>
<h3 id="作为不可变列表的元组"><a href="#作为不可变列表的元组" class="headerlink" title="作为不可变列表的元组"></a>作为不可变列表的元组</h3><p>如果要把元组当作列表来用的话，最好先了解一下它们的相似度如何。在下表中可以清楚地看到，除了跟增减元素相关的方法之外，元组支持列表的其他所有方法。还有一个例外，元组没有 <code>__reversed__</code> 方法，但是这个方法只是个优化而已，reversed(my_tuple) 这个用法在没有 <code>__reversed__</code> 的情况下也是合法的。</p>
<p>列表或元组的方法和属性（那些由object类支持的方法没有列出来）：</p>
<table>
<thead>
<tr>
<th></th>
<th>列表</th>
<th>元组</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>s.__add__(s2)</code></td>
<td>*</td>
<td>*</td>
<td>s + s2，拼接</td>
</tr>
<tr>
<td><code>s.__iadd__(s2)</code></td>
<td>*</td>
<td></td>
<td>s += s2，就地拼接</td>
</tr>
<tr>
<td><code>s.append(e)</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.clear()</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.__contains__(e)</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.copy()</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.count(e)</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.__delitem__(p)</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.extend(it)</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.__getitem__(p)</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.__getnewargs__()</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.index(e)</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.insert(p, e)</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.__iter__()</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.__len__()</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.__mul__(n)</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.__imul__(n)</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.__rmul__(n)</code></td>
<td>*</td>
<td>*</td>
<td></td>
</tr>
<tr>
<td><code>s.pop([p])</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.remove(e)</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.reverse()</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.__reversed__()</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.__setitem__(p,e)</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>s.sort([key],[reverse])</code></td>
<td>*</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>每个 Python 程序员都知道序列可以用 s[a:b] 的形式切片，但是关于切片，我还想说说它的一些不太为人所知的方面。</p>
]]></content>
      <categories>
        <category>流畅的Python</category>
        <category>第二章 序列构成的数组</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>目标主机离线安装Python及pip3</title>
    <url>/2020/09/24/%E7%9B%AE%E6%A0%87%E4%B8%BB%E6%9C%BA%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85Python%E5%8F%8Apip3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>将Python项目文件打包到无法联网的主机上部署执行</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028143859.png"></p>
<a id="more"></a>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近遇到了一个场景：需要将Python项目文件打包到无法联网的主机上部署执行，本篇文章记录针对于该场景的处理方案。</p>
<p>说明：</p>
<p>源主机（可联网）：安装了Python3和pip3</p>
<p>目标主机（无法联网）：需安装和源主机相同的Python版本和pip3，部署执行项目文件</p>
<p>主机系统为centos，Python版本为3.5.2，通过虚拟环境+pip进行迁移</p>
<h3 id="目标主机离线安装Python及pip3"><a href="#目标主机离线安装Python及pip3" class="headerlink" title="目标主机离线安装Python及pip3"></a>目标主机离线安装Python及pip3</h3><h3 id="源主机中下载所需包"><a href="#源主机中下载所需包" class="headerlink" title="源主机中下载所需包"></a>源主机中下载所需包</h3><p><strong>Python3</strong></p>
<p>首先，下载Python3，可以在<a href="https://link.zhihu.com/?target=https://www.python.org/downloads/source/">官网</a>或者通过源主机（可联网的其它主机）wget：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate https://www.python.org/ftp/python/3.5.2/Python-3.5.2.tgz</span><br></pre></td></tr></table></figure>

<p><strong>Python3依赖包</strong></p>
<p>然后，需要下载Python3的依赖包，可以通过centos镜像中去copy，不过我更推荐用yum生成的方式：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">yum install zlib-devel bzip2-devel openssl-devel ncurses-devel  epel-release gcc gcc-c++ xz-devel readline-devel gdbm-devel sqlite-devel tk-devel db4-devel libpcap-devel libffi-devel --downloadonly --downloaddir=/packages</span><br></pre></td></tr></table></figure>

<p>命令执行完毕，你就会在/packages目录下发现所需的所有.rpm文件。</p>
<p>如果，源主机中已经安装了这些依赖，那么你可以用：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">yum reinstall zlib-devel bzip2-devel openssl-devel ncurses-devel  epel-release gcc gcc-c++ xz-devel readline-devel gdbm-devel sqlite-devel tk-devel db4-devel libpcap-devel libffi-devel --downloadonly --downloaddir=/packages</span><br></pre></td></tr></table></figure>

<p>打包：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">zip -r packages.zip packages/</span><br></pre></td></tr></table></figure>

<h3 id="目标主机中安装"><a href="#目标主机中安装" class="headerlink" title="目标主机中安装"></a>目标主机中安装</h3><p>将Python-3.5.2.tgz和packages.zip上传至目标主机。</p>
<p>首先，安装Python3依赖：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">unzip packages.zip</span><br><span class="line">cd packages/</span><br><span class="line">rpm -Uvh  *.rpm --nodeps --force</span><br></pre></td></tr></table></figure>

<p>然后，安装Python3：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">tar -zxvf Python-3.5.2.tgz</span><br><span class="line"></span><br><span class="line">mkdir /usr/local/python3</span><br><span class="line">cd Python-3.5.2 </span><br><span class="line">./configure --prefix=/usr/local/python3                    # 将Python3安装在/usr/local/python3</span><br><span class="line">make &amp;&amp; make install                                       # 编译安装</span><br><span class="line"></span><br><span class="line">ln -s /usr/local/python3/bin/python3 /usr/bin/python3      # 创建python3软链接</span><br><span class="line">ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3            # 创建pip3软链接</span><br></pre></td></tr></table></figure>

<p>安装完毕，可通过：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Python3 -V</span><br><span class="line">pip3 -V</span><br></pre></td></tr></table></figure>

<p>查看并检查安装的版本</p>
<h3 id="源主机中打包项目文件"><a href="#源主机中打包项目文件" class="headerlink" title="源主机中打包项目文件"></a>源主机中打包项目文件</h3><p>若项目中创建虚拟环境，首先激活虚环境，然后进入项目文件，执行：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pip3 freeze &gt; requirements.txt</span><br></pre></td></tr></table></figure>

<p>将当前项目中的库列表生成并保存在requirements.txt中。</p>
<p>然后，通过pip生成批量离线安装包（whl文件）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pip wheel --wheel-dir=./tmp/packages -r requirements.txt</span><br></pre></td></tr></table></figure>

<p>执行完毕之后，你会发现/tmp/packages中包含了项目所需的所有.whl</p>
<p>打包项目文件：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">zip A.zip A/</span><br></pre></td></tr></table></figure>

<h3 id="目标主机中部署"><a href="#目标主机中部署" class="headerlink" title="目标主机中部署"></a>目标主机中部署</h3><p>上传A.zip至目标主机，创建虚环境，并激活（python3 自带了venv）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">python3 -m venv test_venv</span><br><span class="line">cd test_venv</span><br><span class="line">source bin/activate</span><br></pre></td></tr></table></figure>

<p>解压项目代码A.zip，并切换：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">unzip A.zip</span><br><span class="line">cd A/</span><br></pre></td></tr></table></figure>

<p>安装项目Python依赖模块：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pip3 install --no-index --find-links=tmp/packages -r requirements</span><br></pre></td></tr></table></figure>

<p>安装完毕，检查：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">pip3 freeze</span><br></pre></td></tr></table></figure>

<p>当然你也可以通过python命令行import进行检验哈哈。</p>
<p>最后，执行项目启动脚本（startup.sh）部署：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">chmod +x  ./startup.sh</span><br><span class="line">nohup ./startup.sh &gt; a-log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<p>以上，就完成了整个项目的迁移部署。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/114290069">https://zhuanlan.zhihu.com/p/114290069</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>部署博客步骤</title>
    <url>/2020/10/27/%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>博客部署步骤</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028144550.png"></p>
<a id="more"></a>

<h3 id="部署博客步骤"><a href="#部署博客步骤" class="headerlink" title="部署博客步骤"></a>部署博客步骤</h3><h4 id="1-安装PicGo"><a href="#1-安装PicGo" class="headerlink" title="1 安装PicGo"></a>1 安装PicGo</h4><p>去<code>github</code>里面下载<code>PicGo</code>，下载地址：<a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a>。这款软件的主要作用是把本地图片上传到图床上面，比较省心省力。我目前用的图床是<code>gitee</code>。</p>
<p>安装成功后，需要配置参数。如下步骤：</p>
<ul>
<li>在<strong>插件设置</strong>里搜索<code>gitee</code>关键字，选中其中一个搜索出来的结果。<img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201027162831.png"></li>
<li>在<strong>图床设置</strong>里选中<strong>Gitee图床</strong>，设置右边的参数列表。输入用户名、仓库名、路径、私人令牌（<code>gitee</code>上获取）<img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201027163710.png"></li>
</ul>
<h4 id="2-下载博客源代码"><a href="#2-下载博客源代码" class="headerlink" title="2 下载博客源代码"></a>2 下载博客源代码</h4><p>克隆源码地址：<code>git clone git@github.com:wuwenlun/blog.git</code></p>
<p><code>.gitignore</code>文件里的内容是：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br></pre></td></tr></table></figure>



<h4 id="3-部署命令"><a href="#3-部署命令" class="headerlink" title="3 部署命令"></a>3 部署命令</h4><p>可以去<code>hexo</code>官网查看相关命令，官网地址：<a href="https://hexo.bootcss.com/docs/">https://hexo.bootcss.com/docs/</a></p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201027171340.png"></p>
]]></content>
      <categories>
        <category>个人博客</category>
        <category>部署</category>
      </categories>
      <tags>
        <tag>图床</tag>
        <tag>github pages</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>流畅的Python学习笔记-02序列构成的数组-2-4</title>
    <url>/2020/11/03/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-02%E5%BA%8F%E5%88%97%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%BB%84-2-4/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>第二章第四节：切片</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028144038.png"></p>
<a id="more"></a>

<p>在 Python 里，像列表（list）、元组（tuple）和字符串（str）这类序列类型都支持切片操作，但是实际上切片操作比人们所想象的要强大很多。</p>
<p>这一节主要讨论的是这些高级切片形式的用法，它们的实现方法则会在第 10 章的一个自定义类里提到。这么做主要是为了符合这本书的哲学：先讲用法，第四部分中再来讲如何创建新类。</p>
<h3 id="为什么切片和区间会忽略最后一个元素"><a href="#为什么切片和区间会忽略最后一个元素" class="headerlink" title="为什么切片和区间会忽略最后一个元素"></a>为什么切片和区间会忽略最后一个元素</h3><p>Python 在切片和区间操作里不包含区间范围的最后一个元素，这个习惯符合 Python、C 和其他语言里以 0 作为起始下标的传统。这样做带来的好处如下。</p>
<ul>
<li><p>当只有最后一个位置信息时，我们也可以快速看出切片和区间里有几个元素：range(3) 和 my_list[:3] 都返回 3 个元素。</p>
</li>
<li><p>当起止位置信息都可见时，我们可以快速计算出切片和区间的长度，用后一个数减去第一个下标（stop - start）即可。</p>
</li>
<li><p>这样做也让我们可以利用任意一个下标来把序列分割成不重叠的两部分，只要写成 my_list[:x] 和 my_list[x:] 就可以了，如下所示：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[:<span class="number">2</span>] <span class="comment"># 在下标2的地方分割</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:]</span><br><span class="line">[<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[:<span class="number">3</span>] <span class="comment"># 在下标3的地方分割</span></span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">3</span>:]</span><br><span class="line">[<span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br></pre></td></tr></table></figure>

<p>计算机科学家 <code>Edsger W. Dijkstar</code> 对这一风格的解释应该是最好的，详见“延伸阅读”中给出的最后一个参考资料。接下来进一步看看 Python 解释器是如何理解切片操作的。</p>
<h3 id="对对象进行分片"><a href="#对对象进行分片" class="headerlink" title="对对象进行分片"></a>对对象进行分片</h3><p>一个众所周知的秘密是，我们还可以用 <code>s[a:b:c]</code> 的形式对 s 在 a 和 b之间以 c 为间隔取值。c 的值还可以为负，负值意味着反向取值。下面的 3 个例子更直观些：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">&#x27;bicycle&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">3</span>]</span><br><span class="line"><span class="string">&#x27;bye&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">-1</span>]</span><br><span class="line"><span class="string">&#x27;elcycib&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s[::<span class="number">-2</span>]</span><br><span class="line"><span class="string">&#x27;eccb&#x27;</span></span><br></pre></td></tr></table></figure>

<p>另一个例子是在第 1 章中用 deck[12::13] 的形式在未洗过的牌里把每种花色的 A 拿出来：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">12</span>::<span class="number">13</span>]</span><br><span class="line">[Card(rank=<span class="string">&#x27;A&#x27;</span>, suit=<span class="string">&#x27;spades&#x27;</span>), Card(rank=<span class="string">&#x27;A&#x27;</span>, suit=<span class="string">&#x27;diamonds&#x27;</span>),</span><br><span class="line">Card(rank=<span class="string">&#x27;A&#x27;</span>, suit=<span class="string">&#x27;clubs&#x27;</span>), Card(rank=<span class="string">&#x27;A&#x27;</span>, suit=<span class="string">&#x27;hearts&#x27;</span>)]</span><br></pre></td></tr></table></figure>

<p>想要看<code>deck</code>具体是什么数据，请查看该<a href="https://wuwenlun.top/2020/10/22/%E6%B5%81%E7%95%85%E7%9A%84Python%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-01%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B-1-1/">链接</a></p>
<p><code>a:b:c</code> 这种用法只能作为索引或者下标用在 <code>[]</code> 中来返回一个切片对象：<code>slice(a, b, c)</code>，通过内置函数<code>slice</code>返回切片对象。在 10.4.1 节中会讲到，对seq[start:stop:step] 进行求值的时候，Python 会调用<code>seq.__getitem__(slice(start, stop, step))</code>。就算你还不会自定义序列类型，了解一下切片对象也是有好处的。例如你可以给切片命名，就像电子表格软件里给单元格区域取名字一样。</p>
<p>比如，要解析示例 2-11 中所示的纯文本文件，这时使用有名字的切片比用硬编码的数字区间要方便得多，注意示例里的 for 循环的可读性有多强。</p>
<p>示例 2-11 纯文本文件形式的收据以一行字符串的形式被解析：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">invoice = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">0.....6................................40........52...55........</span></span><br><span class="line"><span class="string">1909  Pimoroni PiBrella                $17.50    3    $52.50</span></span><br><span class="line"><span class="string">1489  6mm Tactile Switch x20           $4.95     2    $9.90</span></span><br><span class="line"><span class="string">1510  Panavise Jr. - PV-201            $28.00    1    $28.00</span></span><br><span class="line"><span class="string">1601  PiTFT Mini Kit 320x240           $34.95    1    $34.95</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">SKU = slice(<span class="number">0</span>, <span class="number">6</span>)</span><br><span class="line">DESCRIPTION = slice(<span class="number">6</span>, <span class="number">40</span>)</span><br><span class="line">UNIT_PRICE = slice(<span class="number">40</span>, <span class="number">52</span>)</span><br><span class="line">QUANTITY = slice(<span class="number">52</span>, <span class="number">55</span>)</span><br><span class="line">ITEM_TOTAL = slice(<span class="number">55</span>, <span class="literal">None</span>)</span><br><span class="line">line_items = invoice.split(<span class="string">&#x27;\n&#x27;</span>)[<span class="number">2</span>:]</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> line_items:</span><br><span class="line">print(item[UNIT_PRICE], item[DESCRIPTION])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>$<span class="number">17.50</span> Pimoroni PiBrella</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>$<span class="number">4.95</span> <span class="number">6</span>mm Tactile Switch x20</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>$<span class="number">28.00</span> Panavise Jr. - PV<span class="number">-201</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>$<span class="number">34.95</span> PiTFT Mini Kit <span class="number">320</span>x240</span><br></pre></td></tr></table></figure>

<p>在 10.4 节还有更多机会来了解切片（slice）对象。如果从 Python 用户的角度出发，切片还有个两个额外的功能：多维切片和省略表示法（<code>...</code>）</p>
<h3 id="多维切片和省略"><a href="#多维切片和省略" class="headerlink" title="多维切片和省略"></a>多维切片和省略</h3><p>[] 运算符里还可以使用以逗号分开的多个索引或者是切片，外部库 NumPy 里就用到了这个特性，二维的 <code>numpy.ndarray</code> 就可以用 <code>a[i,j]</code> 这种形式来获取，抑或是用 a[m:n, k:l] 的方式来得到二维切片。稍后的示例 2-22 会展示这个用法。要正确处理这种 [] 运算符的话，对象的特殊方法 <code>__getitem__</code> 和 <code>__setitem__</code> 需要以元组的形式来接收 <code>a[i, j]</code> 中的索引。也就是说，如果要得到 <code>a[i, j]</code> 的值，Python 会调用 <code>a.__getitem__((i, j))</code>。</p>
<p><font color=red><strong>Python 内置的序列类型都是一维的，因此它们只支持单一的索引，成对出现的索引是没有用的。</strong></font></p>
<p>省略（ellipsis）的正确书写方法是三个英语句号（…），省略在 Python 解析器眼里是一个符号，而实际上它是 Ellipsis 对象的别名，而 Ellipsis 对象又是 ellipsis 类的单一实例。 它可以当作切片规范的一部分，也可以用在函数的参数清单中，比如 <code>f(a,..,z)</code>，或 <code>a[i:...]</code>。在 NumPy 中，<code>...</code> 用作多维数组切片的快捷方式。如果 x 是四维数组，那么 <code>x[i, ...]</code> 就是 <code>x[i,:,:,:]</code> 的缩写。如果想了解更多，请参见“Tentative NumPy Tutorial”（<a href="http://wiki.scipy.org/Tentative_NumPy_Tutorial">http://wiki.scipy.org/Tentative_NumPy_Tutorial</a>）。</p>
<blockquote>
<p>是的，你没看错，ellipsis 是类名，全小写，而它的内置实例写作 Ellipsis。这其实跟 bool 是小写，但是它的两个实例写作 True 和 False 异曲同工。</p>
</blockquote>
<p>在写这本书的时候，<font color=red><strong>我还没有发现在 Python 的标准库里有任何Ellipsis 或者是多维索引的用法</strong></font>。如果你知道，请告诉我。这些句法上的特性主要是<font color=red><strong>为了支持用户自定义类或者扩展，比如 NumPy 就是个例子</strong></font>。</p>
<p>除了用来提取序列里的内容，切片还可以用来就地修改可变序列，也就是说修改的时候不需要重新组建序列。</p>
<h3 id="给切片赋值"><a href="#给切片赋值" class="headerlink" title="给切片赋值"></a>给切片赋值</h3><p>如果把切片放在赋值语句的左边，或把它作为 del 操作的对象，我们就可以对序列进行嫁接、切除或就地修改操作。通过下面这几个例子，你应该就能体会到这些操作的强大功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = list(range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> l[<span class="number">5</span>:<span class="number">7</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">3</span>::<span class="number">2</span>] = [<span class="number">11</span>, <span class="number">22</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">11</span>, <span class="number">5</span>, <span class="number">22</span>, <span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = <span class="number">100</span> ➊</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: can only assign an iterable</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">22</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure>

<p>➊ 如果赋值的对象是一个切片，那么赋值语句的右侧必须是个可迭代对象。即便只有单独一个值，也要把它转换成可迭代的序列。</p>
<p>序列的拼接操作可谓是众所周知，任何一本 Python 入门教材都会介绍 <code>+</code> 和 <code>*</code> 的用法，但是在这些用法的背后还有一些可能被忽视的细节。下面就来看看这两种操作。</p>
]]></content>
      <categories>
        <category>流畅的Python</category>
        <category>第二章 序列构成的数组</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机存储术语扇区-磁盘块-页</title>
    <url>/2020/09/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%98%E5%82%A8%E6%9C%AF%E8%AF%AD%E6%89%87%E5%8C%BA-%E7%A3%81%E7%9B%98%E5%9D%97-%E9%A1%B5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>计算机存储术语: 扇区，磁盘块，页</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20201028143444.png"></p>
<a id="more"></a>

<h3 id="扇区（sector）"><a href="#扇区（sector）" class="headerlink" title="扇区（sector）"></a>扇区（sector）</h3><p>硬盘的读写以扇区为基本单位。磁盘上的每个磁道被等分为若干个弧段，这些弧段称之为扇区。硬盘的物理读写以扇区为基本单位。通常情况下每个扇区的大小是 512 字节。linux 下可以使用 <code>fdisk -l</code> 了解扇区大小：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo /sbin/fdisk -l</span><br><span class="line">Disk /dev/sda: 20 GiB, 21474836480 bytes, 41943040 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x7d9f5643</span><br></pre></td></tr></table></figure>

<p>其中 Sector size，就是扇区大小，本例中为 512 bytes。</p>
<p>注意，扇区是磁盘物理层面的概念，操作系统是不直接与扇区交互的，而是与多个连续扇区组成的磁盘块交互。由于扇区是物理层面的概念，所以无法在系统中进行大小的更改。</p>
<h3 id="磁盘块（IO-Block）"><a href="#磁盘块（IO-Block）" class="headerlink" title="磁盘块（IO Block）"></a>磁盘块（IO Block）</h3><p>文件系统读写数据的最小单位，也叫磁盘簇。扇区是磁盘最小的物理存储单元，操作系统将相邻的扇区组合在一起，形成一个块，对块进行管理。每个磁盘块可以包括 2、4、8、16、32 或 64 个扇区。磁盘块是操作系统所使用的逻辑概念，而非磁盘的物理概念。磁盘块的大小可以通过命令 <code>stat /boot</code> 来查看：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo <span class="built_in">stat</span> /boot</span><br><span class="line">File: /boot</span><br><span class="line">Size: 4096        Blocks: 8          IO Block: 4096   directory</span><br><span class="line">Device: 801h/2049d  Inode: 655361      Links: 3</span><br><span class="line">Access: (0755/drwxr-xr-x)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2019-07-06 20:19:45.487160301 +0800</span><br><span class="line">Modify: 2019-07-06 20:19:44.835160301 +0800</span><br><span class="line">Change: 2019-07-06 20:19:44.835160301 +0800</span><br><span class="line">Birth: -</span><br></pre></td></tr></table></figure>

<p>其中 IO Block 就是磁盘块大小，本例中是 4096 Bytes，一般也是 4K。</p>
<p>为了更好地管理磁盘空间和更高效地从硬盘读取数据，操作系统规定一个磁盘块中只能放置一个文件，因此文件所占用的空间，只能是磁盘块的整数倍，那就意味着会出现文件的实际大小，会小于其所占用的磁盘空间的情况。</p>
<p><img src="https://gitee.com/wuwenlun/img-bed/raw/master/img/20200924170507.jpg" alt="img"></p>
<p>test2.txt是一个只包含一个字母的文本文档。它的理论大小是一个字节，但是由于系统的磁盘块大小是4KB（文件的最小存储大小单位），所以test2.txt占据的磁盘实际空间是4KB</p>
<p>操作系统不能对磁盘扇区直接寻址操写，主要原因是扇区数量庞大，因此才将多个连续扇区组合一起操作。磁盘块的大小是可以通过blockdev命令更改的。</p>
<h3 id="页（page）"><a href="#页（page）" class="headerlink" title="页（page）"></a>页（page）</h3><p>内存的最小存储单位。页的大小通常为磁盘块大小的 2^n 倍，可以通过命令 <code>getconf PAGE_SIZE</code> 来获取页的大小：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">$sudo getconf PAGE_SIZE</span><br><span class="line">4096</span><br></pre></td></tr></table></figure>

<p>本例中为 4096 Bytes，与磁盘块大小一致。</p>
<p>总结两个逻辑单位：</p>
<ul>
<li>页，内存操作的基本单位</li>
<li>磁盘块，磁盘操作的基本单位</li>
</ul>
<p>为了尽量减少I/O操作，计算机系统一般采取预读的方式，预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<p>计算机系统是分页读取和存储的，一般一页为4KB（8个扇区，每个扇区512个字节）。每次读取和存取的最小单元为一页，而磁盘预读时通常会读取页的整倍数。根据文章上述的【局部性原理】①当一个数据被用到时，其附近的数据也通常会马上被使用。②程序运行期间所需要的数据通常比较集中。由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），所以即使只需要读取一个字节，磁盘也会读取一页的数据。</p>
<p>至于磁盘分页，参考计算机操作系统的分页，分段存储管理——逻辑地址和物理地址被分为大小相同的页面，逻辑地址中叫页，物理地址中叫块。</p>
]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
